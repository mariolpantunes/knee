<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>knee.kneedle API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>knee.kneedle</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding: utf-8

__author__ = &#39;Mário Antunes&#39;
__version__ = &#39;0.1&#39;
__email__ = &#39;mariolpantunes@gmail.com&#39;
__status__ = &#39;Development&#39;


import math
import enum
import logging
import numpy as np
import uts.ema as ema
import uts.peak_detection as pd
import knee.multi_knee as mk
import knee.linear_fit as lf


logger = logging.getLogger(__name__)


class Direction(enum.Enum):
    &#34;&#34;&#34;
    Enum data type that represents the direction of a concavity.
    &#34;&#34;&#34;
    Increasing = &#39;increasing&#39;
    Decreasing = &#39;decreasing&#39;

    def __str__(self):
        return self.value


class Concavity(enum.Enum):
    &#34;&#34;&#34;
    Enum data type that represents the rotation of a concavity.
    &#34;&#34;&#34;
    Counterclockwise = &#39;counter-clockwise&#39;
    Clockwise = &#39;clockwise&#39;

    def __str__(self):
        return self.value


class PeakDetection(enum.Enum):
    &#34;&#34;&#34;
    Enum data type that identifies the peak selection algorithm.
    &#34;&#34;&#34;
    Kneedle = &#39;Kneedle&#39;
    ZScore = &#39;ZScore&#39;
    Significant = &#39;Significant&#39;
    All = &#39;All&#39;

    def __str__(self):
        return self.value


def differences(points: np.ndarray, cd: Direction, cc: Concavity) -&gt; np.ndarray:
    &#34;&#34;&#34;Computes the differences from the y axis.

    These differences represent a rotation within the original algorithm.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        cd (Direction): direction of the concavity
        cc (Concavity): rotation of the concavity

    Returns:
        np.ndarray: the points array with the differences
    &#34;&#34;&#34;

    rv = np.empty(points.shape)

    if cd is Direction.Decreasing and cc is Concavity.Clockwise:
        for i in range(0, len(points)):
            rv[i][0] = points[i][0]
            rv[i][1] = points[i][0] + points[i][1]  # x + y
    elif cd is Direction.Decreasing and cc is Concavity.Counterclockwise:
        for i in range(0, len(points)):
            rv[i][0] = points[i][0]
            rv[i][1] = 1.0 - (points[i][0] + points[i][1])  # 1.0 - (x + y)
    elif cd is Direction.Increasing and cc is Concavity.Clockwise:
        for i in range(0, len(points)):
            rv[i][0] = points[i][0]
            rv[i][1] = points[i][1] - points[i][0]  # y - x
    else:
        for i in range(0, len(points)):
            rv[i][0] = points[i][0]
            rv[i][1] = math.fabs(points[i][1] - points[i][0])  # abs(y - x)

    return rv


def knee(points: np.ndarray, t: float, cd: Direction, cc: Concavity) -&gt; int:
    &#34;&#34;&#34;Returns the index of the knee point based on the Kneedle method.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        t (float): tau of the side window used to smooth the curve
        cd (Direction): direction of the concavity
        cc (Concavity): rotation of the concavity

    Returns:
        int: the index of the knee point
    &#34;&#34;&#34;

    Ds = ema.linear(points, t)
    pmin = Ds.min(axis=0)
    pmax = Ds.max(axis=0)
    diff = pmax - pmin
    diff[diff == 0] = 1.0

    Dn = (Ds - pmin)/diff 

    Dd = differences(Dn, cd, cc)

    peaks = pd.all_peaks(Dd)
    
    idx = pd.highest_peak(Dd, peaks)
    if idx == -1:
        return None
    else:
        return idx


def knees(points: np.ndarray, t: float, cd: Direction, cc: Concavity, sensitivity:float=1.0, p:PeakDetection=PeakDetection.Kneedle, debug:bool=False) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the index of the knees point based on the Kneedle method.

    This implementation uses an heuristic to automatically define
    the direction and rotation of the concavity.

    Furthermore, it support three different methods to select the 
    relevant knees:
    1. Kneedle    : classical algorithm
    2. Significant: significant knee peak detection
    3. ZScore     : significant knee peak detection based on zscore

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        t (float): tau of the sliding window used to smooth the curve
        cd (Direction): direction of the concavity
        cc (Concavity): rotation of the concavity
        sensitivity (float): controls the sensitivity of the peak detection (default 1.0)
        p (PeakDetection): selects the peak detection method (default PeakDetection.Kneedle)
        debug (bool): debug flag; when True the algorithm returns more information

    Returns:
        np.ndarray: the indexes of the knee points
    &#34;&#34;&#34;
    Ds = ema.linear(points, t)

    pmin = Ds.min(axis=0)
    pmax = Ds.max(axis=0)
    Dn = (Ds - pmin)/(pmax - pmin)

    Dd = differences(Dn, cd, cc)

    knees = []

    peaks_idx = pd.all_peaks(Dd)

    if p is PeakDetection.Kneedle:
        knees = pd.kneedle_peak_detection(Dd, peaks_idx, sensitivity)
    elif p is PeakDetection.Significant:
        knees = pd.significant_peaks(Dd, peaks_idx, sensitivity)
    elif p is PeakDetection.ZScore:
        knees = pd.significant_zscore_peaks(Dd, peaks_idx, sensitivity)
    else:
        knees = peaks_idx

    if debug is True:
        return {&#39;knees&#39;: knees, &#39;dd&#39;: Dd, &#39;peaks&#39;: pd.all_peaks(Dd)}
    else:
        return knees


def auto_knees(points: np.ndarray,  t: float = 1.0, sensitivity: float = 1.0, p: PeakDetection = PeakDetection.Kneedle) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the index of the knees point based on the Kneedle method.

    This implementation uses an heuristic to automatically define
    the direction and rotation of the concavity.

    Furthermore, it support three different methods to select the 
    relevant knees:
    1. Kneedle    : classical algorithm
    2. Significant: significant knee peak detection
    3. ZScore     : significant knee peak detection based on zscore

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        t (float): tau of the side window used to smooth the curve
        sensitivity (float): controls the sensitivity of the peak detection
        p (PeakDetection): selects the peak detection method

    Returns:
        np.ndarray: the indexes of the knee points
    &#34;&#34;&#34;
    _, m = lf.linear_fit_points(points)

    if m &gt; 0.0:
        cd = Direction.Increasing
    else:
        cd = Direction.Decreasing

    knees_1= knees(points, t, cd, Concavity.Counterclockwise, sensitivity, p)
    knees_2 = knees(points, t, cd, Concavity.Clockwise, sensitivity, p)

    knees_idx = np.concatenate((knees_1, knees_2))
    # np.concatenate generates float array when one is empty (see https://github.com/numpy/numpy/issues/8878)
    knees_idx = knees_idx.astype(int)
    knees_idx = np.unique(knees_idx)
    knees_idx.sort()

    return knees_idx


def auto_knee(points: np.ndarray, t: float = 1.0) -&gt; int:
    &#34;&#34;&#34;Returns the index of the knee point based on the Kneedle method.

    This implementation uses an heuristic to automatically define
    the direction and rotation of the concavity.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        t (float): tau of the side window used to smooth the curve

    Returns:
        int: the index of the knee point
    &#34;&#34;&#34;
    b, m = lf.linear_fit_points(points)

    if m &gt; 0.0:
        cd = Direction.Increasing
    else:
        cd = Direction.Decreasing

    y = points[:, 1]
    yhat = np.empty(len(points))
    for i in range(0, len(points)):
        yhat[i] = points[i][0]*m+b

    vote = np.sum(y - yhat)

    if cd is Direction.Increasing and vote &gt; 0:
        cc = Concavity.Clockwise
    elif cd is Direction.Increasing and vote &lt;= 0:
        cc = Concavity.Counterclockwise
    elif cd is Direction.Decreasing and vote &gt; 0:
        cc = Concavity.Clockwise
    else:
        cc = Concavity.Counterclockwise

    return knee(points, t, cd, cc)


def multi_knee(points, t1=0.01, t2=3):
    &#34;&#34;&#34;
    Recursive knee point detection based on Kneedle.

    It returns the knee points on the curve.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        t1 (float): coefficient of determination threshold (default 0.01)
        t2 (int): number of points threshold (default 3)

    Returns:
        np.ndarray: knee points on the curve

    &#34;&#34;&#34;
    knees = mk.multi_knee(auto_knee, points, t1, t2)
    return knees</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="knee.kneedle.auto_knee"><code class="name flex">
<span>def <span class="ident">auto_knee</span></span>(<span>points: numpy.ndarray, t: float = 1.0) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the index of the knee point based on the Kneedle method.</p>
<p>This implementation uses an heuristic to automatically define
the direction and rotation of the concavity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>tau of the side window used to smooth the curve</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the index of the knee point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def auto_knee(points: np.ndarray, t: float = 1.0) -&gt; int:
    &#34;&#34;&#34;Returns the index of the knee point based on the Kneedle method.

    This implementation uses an heuristic to automatically define
    the direction and rotation of the concavity.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        t (float): tau of the side window used to smooth the curve

    Returns:
        int: the index of the knee point
    &#34;&#34;&#34;
    b, m = lf.linear_fit_points(points)

    if m &gt; 0.0:
        cd = Direction.Increasing
    else:
        cd = Direction.Decreasing

    y = points[:, 1]
    yhat = np.empty(len(points))
    for i in range(0, len(points)):
        yhat[i] = points[i][0]*m+b

    vote = np.sum(y - yhat)

    if cd is Direction.Increasing and vote &gt; 0:
        cc = Concavity.Clockwise
    elif cd is Direction.Increasing and vote &lt;= 0:
        cc = Concavity.Counterclockwise
    elif cd is Direction.Decreasing and vote &gt; 0:
        cc = Concavity.Clockwise
    else:
        cc = Concavity.Counterclockwise

    return knee(points, t, cd, cc)</code></pre>
</details>
</dd>
<dt id="knee.kneedle.auto_knees"><code class="name flex">
<span>def <span class="ident">auto_knees</span></span>(<span>points: numpy.ndarray, t: float = 1.0, sensitivity: float = 1.0, p: <a title="knee.kneedle.PeakDetection" href="#knee.kneedle.PeakDetection">PeakDetection</a> = Kneedle) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the index of the knees point based on the Kneedle method.</p>
<p>This implementation uses an heuristic to automatically define
the direction and rotation of the concavity.</p>
<p>Furthermore, it support three different methods to select the
relevant knees:
1. Kneedle
: classical algorithm
2. Significant: significant knee peak detection
3. ZScore
: significant knee peak detection based on zscore</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>tau of the side window used to smooth the curve</dd>
<dt><strong><code>sensitivity</code></strong> :&ensp;<code>float</code></dt>
<dd>controls the sensitivity of the peak detection</dd>
<dt><strong><code>p</code></strong> :&ensp;<code><a title="knee.kneedle.PeakDetection" href="#knee.kneedle.PeakDetection">PeakDetection</a></code></dt>
<dd>selects the peak detection method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>the indexes of the knee points</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def auto_knees(points: np.ndarray,  t: float = 1.0, sensitivity: float = 1.0, p: PeakDetection = PeakDetection.Kneedle) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the index of the knees point based on the Kneedle method.

    This implementation uses an heuristic to automatically define
    the direction and rotation of the concavity.

    Furthermore, it support three different methods to select the 
    relevant knees:
    1. Kneedle    : classical algorithm
    2. Significant: significant knee peak detection
    3. ZScore     : significant knee peak detection based on zscore

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        t (float): tau of the side window used to smooth the curve
        sensitivity (float): controls the sensitivity of the peak detection
        p (PeakDetection): selects the peak detection method

    Returns:
        np.ndarray: the indexes of the knee points
    &#34;&#34;&#34;
    _, m = lf.linear_fit_points(points)

    if m &gt; 0.0:
        cd = Direction.Increasing
    else:
        cd = Direction.Decreasing

    knees_1= knees(points, t, cd, Concavity.Counterclockwise, sensitivity, p)
    knees_2 = knees(points, t, cd, Concavity.Clockwise, sensitivity, p)

    knees_idx = np.concatenate((knees_1, knees_2))
    # np.concatenate generates float array when one is empty (see https://github.com/numpy/numpy/issues/8878)
    knees_idx = knees_idx.astype(int)
    knees_idx = np.unique(knees_idx)
    knees_idx.sort()

    return knees_idx</code></pre>
</details>
</dd>
<dt id="knee.kneedle.differences"><code class="name flex">
<span>def <span class="ident">differences</span></span>(<span>points: numpy.ndarray, cd: <a title="knee.kneedle.Direction" href="#knee.kneedle.Direction">Direction</a>, cc: <a title="knee.kneedle.Concavity" href="#knee.kneedle.Concavity">Concavity</a>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the differences from the y axis.</p>
<p>These differences represent a rotation within the original algorithm.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>cd</code></strong> :&ensp;<code><a title="knee.kneedle.Direction" href="#knee.kneedle.Direction">Direction</a></code></dt>
<dd>direction of the concavity</dd>
<dt><strong><code>cc</code></strong> :&ensp;<code><a title="knee.kneedle.Concavity" href="#knee.kneedle.Concavity">Concavity</a></code></dt>
<dd>rotation of the concavity</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>the points array with the differences</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def differences(points: np.ndarray, cd: Direction, cc: Concavity) -&gt; np.ndarray:
    &#34;&#34;&#34;Computes the differences from the y axis.

    These differences represent a rotation within the original algorithm.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        cd (Direction): direction of the concavity
        cc (Concavity): rotation of the concavity

    Returns:
        np.ndarray: the points array with the differences
    &#34;&#34;&#34;

    rv = np.empty(points.shape)

    if cd is Direction.Decreasing and cc is Concavity.Clockwise:
        for i in range(0, len(points)):
            rv[i][0] = points[i][0]
            rv[i][1] = points[i][0] + points[i][1]  # x + y
    elif cd is Direction.Decreasing and cc is Concavity.Counterclockwise:
        for i in range(0, len(points)):
            rv[i][0] = points[i][0]
            rv[i][1] = 1.0 - (points[i][0] + points[i][1])  # 1.0 - (x + y)
    elif cd is Direction.Increasing and cc is Concavity.Clockwise:
        for i in range(0, len(points)):
            rv[i][0] = points[i][0]
            rv[i][1] = points[i][1] - points[i][0]  # y - x
    else:
        for i in range(0, len(points)):
            rv[i][0] = points[i][0]
            rv[i][1] = math.fabs(points[i][1] - points[i][0])  # abs(y - x)

    return rv</code></pre>
</details>
</dd>
<dt id="knee.kneedle.knee"><code class="name flex">
<span>def <span class="ident">knee</span></span>(<span>points: numpy.ndarray, t: float, cd: <a title="knee.kneedle.Direction" href="#knee.kneedle.Direction">Direction</a>, cc: <a title="knee.kneedle.Concavity" href="#knee.kneedle.Concavity">Concavity</a>) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the index of the knee point based on the Kneedle method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>tau of the side window used to smooth the curve</dd>
<dt><strong><code>cd</code></strong> :&ensp;<code><a title="knee.kneedle.Direction" href="#knee.kneedle.Direction">Direction</a></code></dt>
<dd>direction of the concavity</dd>
<dt><strong><code>cc</code></strong> :&ensp;<code><a title="knee.kneedle.Concavity" href="#knee.kneedle.Concavity">Concavity</a></code></dt>
<dd>rotation of the concavity</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the index of the knee point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def knee(points: np.ndarray, t: float, cd: Direction, cc: Concavity) -&gt; int:
    &#34;&#34;&#34;Returns the index of the knee point based on the Kneedle method.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        t (float): tau of the side window used to smooth the curve
        cd (Direction): direction of the concavity
        cc (Concavity): rotation of the concavity

    Returns:
        int: the index of the knee point
    &#34;&#34;&#34;

    Ds = ema.linear(points, t)
    pmin = Ds.min(axis=0)
    pmax = Ds.max(axis=0)
    diff = pmax - pmin
    diff[diff == 0] = 1.0

    Dn = (Ds - pmin)/diff 

    Dd = differences(Dn, cd, cc)

    peaks = pd.all_peaks(Dd)
    
    idx = pd.highest_peak(Dd, peaks)
    if idx == -1:
        return None
    else:
        return idx</code></pre>
</details>
</dd>
<dt id="knee.kneedle.knees"><code class="name flex">
<span>def <span class="ident">knees</span></span>(<span>points: numpy.ndarray, t: float, cd: <a title="knee.kneedle.Direction" href="#knee.kneedle.Direction">Direction</a>, cc: <a title="knee.kneedle.Concavity" href="#knee.kneedle.Concavity">Concavity</a>, sensitivity: float = 1.0, p: <a title="knee.kneedle.PeakDetection" href="#knee.kneedle.PeakDetection">PeakDetection</a> = Kneedle, debug: bool = False) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the index of the knees point based on the Kneedle method.</p>
<p>This implementation uses an heuristic to automatically define
the direction and rotation of the concavity.</p>
<p>Furthermore, it support three different methods to select the
relevant knees:
1. Kneedle
: classical algorithm
2. Significant: significant knee peak detection
3. ZScore
: significant knee peak detection based on zscore</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>tau of the sliding window used to smooth the curve</dd>
<dt><strong><code>cd</code></strong> :&ensp;<code><a title="knee.kneedle.Direction" href="#knee.kneedle.Direction">Direction</a></code></dt>
<dd>direction of the concavity</dd>
<dt><strong><code>cc</code></strong> :&ensp;<code><a title="knee.kneedle.Concavity" href="#knee.kneedle.Concavity">Concavity</a></code></dt>
<dd>rotation of the concavity</dd>
<dt><strong><code>sensitivity</code></strong> :&ensp;<code>float</code></dt>
<dd>controls the sensitivity of the peak detection (default 1.0)</dd>
<dt><strong><code>p</code></strong> :&ensp;<code><a title="knee.kneedle.PeakDetection" href="#knee.kneedle.PeakDetection">PeakDetection</a></code></dt>
<dd>selects the peak detection method (default PeakDetection.Kneedle)</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>debug flag; when True the algorithm returns more information</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>the indexes of the knee points</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def knees(points: np.ndarray, t: float, cd: Direction, cc: Concavity, sensitivity:float=1.0, p:PeakDetection=PeakDetection.Kneedle, debug:bool=False) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the index of the knees point based on the Kneedle method.

    This implementation uses an heuristic to automatically define
    the direction and rotation of the concavity.

    Furthermore, it support three different methods to select the 
    relevant knees:
    1. Kneedle    : classical algorithm
    2. Significant: significant knee peak detection
    3. ZScore     : significant knee peak detection based on zscore

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        t (float): tau of the sliding window used to smooth the curve
        cd (Direction): direction of the concavity
        cc (Concavity): rotation of the concavity
        sensitivity (float): controls the sensitivity of the peak detection (default 1.0)
        p (PeakDetection): selects the peak detection method (default PeakDetection.Kneedle)
        debug (bool): debug flag; when True the algorithm returns more information

    Returns:
        np.ndarray: the indexes of the knee points
    &#34;&#34;&#34;
    Ds = ema.linear(points, t)

    pmin = Ds.min(axis=0)
    pmax = Ds.max(axis=0)
    Dn = (Ds - pmin)/(pmax - pmin)

    Dd = differences(Dn, cd, cc)

    knees = []

    peaks_idx = pd.all_peaks(Dd)

    if p is PeakDetection.Kneedle:
        knees = pd.kneedle_peak_detection(Dd, peaks_idx, sensitivity)
    elif p is PeakDetection.Significant:
        knees = pd.significant_peaks(Dd, peaks_idx, sensitivity)
    elif p is PeakDetection.ZScore:
        knees = pd.significant_zscore_peaks(Dd, peaks_idx, sensitivity)
    else:
        knees = peaks_idx

    if debug is True:
        return {&#39;knees&#39;: knees, &#39;dd&#39;: Dd, &#39;peaks&#39;: pd.all_peaks(Dd)}
    else:
        return knees</code></pre>
</details>
</dd>
<dt id="knee.kneedle.multi_knee"><code class="name flex">
<span>def <span class="ident">multi_knee</span></span>(<span>points, t1=0.01, t2=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursive knee point detection based on Kneedle.</p>
<p>It returns the knee points on the curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>t1</code></strong> :&ensp;<code>float</code></dt>
<dd>coefficient of determination threshold (default 0.01)</dd>
<dt><strong><code>t2</code></strong> :&ensp;<code>int</code></dt>
<dd>number of points threshold (default 3)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>knee points on the curve</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multi_knee(points, t1=0.01, t2=3):
    &#34;&#34;&#34;
    Recursive knee point detection based on Kneedle.

    It returns the knee points on the curve.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        t1 (float): coefficient of determination threshold (default 0.01)
        t2 (int): number of points threshold (default 3)

    Returns:
        np.ndarray: knee points on the curve

    &#34;&#34;&#34;
    knees = mk.multi_knee(auto_knee, points, t1, t2)
    return knees</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="knee.kneedle.Concavity"><code class="flex name class">
<span>class <span class="ident">Concavity</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum data type that represents the rotation of a concavity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Concavity(enum.Enum):
    &#34;&#34;&#34;
    Enum data type that represents the rotation of a concavity.
    &#34;&#34;&#34;
    Counterclockwise = &#39;counter-clockwise&#39;
    Clockwise = &#39;clockwise&#39;

    def __str__(self):
        return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="knee.kneedle.Concavity.Clockwise"><code class="name">var <span class="ident">Clockwise</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="knee.kneedle.Concavity.Counterclockwise"><code class="name">var <span class="ident">Counterclockwise</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="knee.kneedle.Direction"><code class="flex name class">
<span>class <span class="ident">Direction</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum data type that represents the direction of a concavity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Direction(enum.Enum):
    &#34;&#34;&#34;
    Enum data type that represents the direction of a concavity.
    &#34;&#34;&#34;
    Increasing = &#39;increasing&#39;
    Decreasing = &#39;decreasing&#39;

    def __str__(self):
        return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="knee.kneedle.Direction.Decreasing"><code class="name">var <span class="ident">Decreasing</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="knee.kneedle.Direction.Increasing"><code class="name">var <span class="ident">Increasing</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="knee.kneedle.PeakDetection"><code class="flex name class">
<span>class <span class="ident">PeakDetection</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum data type that identifies the peak selection algorithm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PeakDetection(enum.Enum):
    &#34;&#34;&#34;
    Enum data type that identifies the peak selection algorithm.
    &#34;&#34;&#34;
    Kneedle = &#39;Kneedle&#39;
    ZScore = &#39;ZScore&#39;
    Significant = &#39;Significant&#39;
    All = &#39;All&#39;

    def __str__(self):
        return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="knee.kneedle.PeakDetection.All"><code class="name">var <span class="ident">All</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="knee.kneedle.PeakDetection.Kneedle"><code class="name">var <span class="ident">Kneedle</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="knee.kneedle.PeakDetection.Significant"><code class="name">var <span class="ident">Significant</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="knee.kneedle.PeakDetection.ZScore"><code class="name">var <span class="ident">ZScore</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="knee" href="index.html">knee</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="knee.kneedle.auto_knee" href="#knee.kneedle.auto_knee">auto_knee</a></code></li>
<li><code><a title="knee.kneedle.auto_knees" href="#knee.kneedle.auto_knees">auto_knees</a></code></li>
<li><code><a title="knee.kneedle.differences" href="#knee.kneedle.differences">differences</a></code></li>
<li><code><a title="knee.kneedle.knee" href="#knee.kneedle.knee">knee</a></code></li>
<li><code><a title="knee.kneedle.knees" href="#knee.kneedle.knees">knees</a></code></li>
<li><code><a title="knee.kneedle.multi_knee" href="#knee.kneedle.multi_knee">multi_knee</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="knee.kneedle.Concavity" href="#knee.kneedle.Concavity">Concavity</a></code></h4>
<ul class="">
<li><code><a title="knee.kneedle.Concavity.Clockwise" href="#knee.kneedle.Concavity.Clockwise">Clockwise</a></code></li>
<li><code><a title="knee.kneedle.Concavity.Counterclockwise" href="#knee.kneedle.Concavity.Counterclockwise">Counterclockwise</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="knee.kneedle.Direction" href="#knee.kneedle.Direction">Direction</a></code></h4>
<ul class="">
<li><code><a title="knee.kneedle.Direction.Decreasing" href="#knee.kneedle.Direction.Decreasing">Decreasing</a></code></li>
<li><code><a title="knee.kneedle.Direction.Increasing" href="#knee.kneedle.Direction.Increasing">Increasing</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="knee.kneedle.PeakDetection" href="#knee.kneedle.PeakDetection">PeakDetection</a></code></h4>
<ul class="">
<li><code><a title="knee.kneedle.PeakDetection.All" href="#knee.kneedle.PeakDetection.All">All</a></code></li>
<li><code><a title="knee.kneedle.PeakDetection.Kneedle" href="#knee.kneedle.PeakDetection.Kneedle">Kneedle</a></code></li>
<li><code><a title="knee.kneedle.PeakDetection.Significant" href="#knee.kneedle.PeakDetection.Significant">Significant</a></code></li>
<li><code><a title="knee.kneedle.PeakDetection.ZScore" href="#knee.kneedle.PeakDetection.ZScore">ZScore</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>