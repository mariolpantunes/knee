<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>knee.evaluation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>knee.evaluation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding: utf-8

__author__ = &#39;MÃ¡rio Antunes&#39;
__version__ = &#39;0.1&#39;
__email__ = &#39;mariolpantunes@gmail.com&#39;
__status__ = &#39;Development&#39;


import enum
import math
import logging
import numpy as np
import knee.linear_fit as lf


logger = logging.getLogger(__name__)


class Strategy(enum.Enum):
    &#34;&#34;&#34;
    Enum data type that represents the strategy of MAE, MSE and RMSE
    &#34;&#34;&#34;
    knees = &#39;knees&#39;
    expected = &#39;expected&#39;
    best = &#39;best&#39;
    worst = &#39;worst&#39;

    def __str__(self):
        return self.value


def get_neighbourhood_points(points: np.ndarray, a: int, b: int, t: float) -&gt; tuple:
    &#34;&#34;&#34;Get the neighbourhood (closest points) from a to b.

    The neighbourhood is defined as the longest straitgh line (defined by R2).

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        a (int): the initial point of the search
        b (int): the left limit of the search
        t (float): R2 threshold

    Returns:
        tuple: (neighbourhood index, r2, slope)
    &#34;&#34;&#34;

    x = points[:, 0]
    y = points[:, 1]
    return get_neighbourhood(x, y, a, b, t)


def get_neighbourhood_fast_points(points: np.ndarray, a: int, b: int, t: float) -&gt; tuple:
    &#34;&#34;&#34;Get the neighbourhood (closest points) from a to b.

    The neighbourhood is defined as the longest straitgh line (defined by R2).
    This version uses a inaccurate binary search to speedup the search.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        a (int): the initial point of the search
        b (int): the left limit of the search
        t (float): R2 threshold

    Returns:
        tuple: (neighbourhood index, r2, slope)
    &#34;&#34;&#34;

    x = points[:, 0]
    y = points[:, 1]
    return get_neighbourhood_fast(x, y, a, b, t)


def get_neighbourhood_binary(x: np.ndarray, y: np.ndarray, a: int, b: int, t=0.9) -&gt; int:
    &#34;&#34;&#34;
    Get the index of the point within the range [b, a] where the R2 is close to the threshold.

    This version uses a inaccurate binary search to speedup the search.

    Args:
        x (np.ndarray): the value of the points in the x axis coordinates
        y (np.ndarray): the value of the points in the y axis coordinates
        a (int): the initial point of the search
        b (int): the left limit of the search
        t (float): R2 threshold (default 0.9)

    Returns:
        int: index of the point
    &#34;&#34;&#34;

    i = b
    right = a

    while abs(i-right) &gt; 1:
        coef = lf.linear_fit(x[i:a+1], y[i:a+1])
        r2 = lf.linear_r2(x[i:a+1], y[i:a+1], coef)

        if r2 &lt; t:
            i = int((i+right)/2.0)
        else:
            right = i
            i = int((b+right)/2.0)

    return i


def get_neighbourhood_fast(x: np.ndarray, y: np.ndarray, a: int, b: int, t: float = 0.9) -&gt; tuple:
    &#34;&#34;&#34;
    Get the neighbourhood (closest points) from a to b.

    The neighbourhood is defined as the longest straitgh line (defined by R2).
    This version uses a inaccurate binary search to speedup the search.

    Args:
        x (np.ndarray): the value of the points in the x axis coordinates
        y (np.ndarray): the value of the points in the y axis coordinates
        a (int): the initial point of the search
        b (int): the left limit of the search
        t (float): R2 threshold (default 0.9)

    Returns:
        tuple: (neighbourhood index, r2, slope)
    &#34;&#34;&#34;
    # speedup when the search using an inaccurate binary search
    i = get_neighbourhood_binary(x, y, a, b, t)
    b, slope = lf.linear_fit(x[i:a+1], y[i:a+1])
    r2 = lf.linear_r2(x[i:a+1], y[i:a+1], (b, slope))
    previous_res = (i, r2, slope)

    # Linear search to improve accuracy
    while r2 &lt; t and i &lt; a:
        i += 1
        coef = lf.linear_fit(x[i:a+1], y[i:a+1])
        r2 = lf.linear_r2(x[i:a+1], y[i:a+1], coef)
        _, slope = coef
        previous_res = (i, r2, slope)

    return previous_res


def get_neighbourhood(x: np.ndarray, y: np.ndarray, a: int, b: int, t: float = 0.9) -&gt; tuple:
    &#34;&#34;&#34;
    Get the neighbourhood (closest points) from a to b.

    The neighbourhood is defined as the longest straitgh line (defined by R2).

    Args:
        x (np.ndarray): the value of the points in the x axis coordinates
        y (np.ndarray): the value of the points in the y axis coordinates
        a (int): the initial point of the search
        b (int): the left limit of the search
        t (float): R2 threshold (default 0.9)

    Returns:
        tuple: (neighbourhood index, r2, slope)
    &#34;&#34;&#34;

    r2 = 1.0
    i = a - 1
    _, slope = lf.linear_fit(x[i:a+1], y[i:a+1])

    while r2 &gt; t and i &gt; b:
        # print(&#39;.&#39;)
        previous_res = (i, r2, slope)
        i -= 1
        coef = lf.linear_fit(x[i:a+1], y[i:a+1])
        r2 = lf.linear_r2(x[i:a+1], y[i:a+1], coef)
        _, slope = coef
        #print(f&#39;{i} -&gt; {r2}&#39;)

    if r2 &gt; t:
        return i, r2, slope
    else:
        return previous_res


def accuracy_knee(points: np.ndarray, knees: np.ndarray, t: float = 0.9) -&gt; tuple:
    &#34;&#34;&#34;Compute the accuracy heuristic for a set of knees.

    The heuristic is based on the average distance of X and Y axis, the slope and the R2.
    In this version it is used the left neighbourhood of the knee.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        t (float): R2 threshold (default 0.9)

    Returns:
        tuple: (average_x, average_y, average_slope, average_coeffients, cost)
    &#34;&#34;&#34;
    x = points[:, 0]
    y = points[:, 1]

    total_x = math.fabs(x[-1] - x[0])
    total_y = math.fabs(y[-1] - y[0])

    distances_x = []
    distances_y = []
    slopes = []
    coeffients = []

    previous_knee = 0
    for i in range(len(knees)):
        idx, r2, slope = get_neighbourhood_fast(x, y, knees[i], previous_knee)

        delta_x = x[idx] - x[knees[i]]
        delta_y = y[idx] - y[knees[i]]

        distances_x.append(math.fabs(delta_x))
        distances_y.append(math.fabs(delta_y))
        slopes.append(math.fabs(slope))
        coeffients.append(r2)

        previous_knee = knees[i]

    slopes = np.array(slopes)
    slopes = slopes/slopes.max()

    coeffients = np.array(coeffients)
    coeffients = coeffients/coeffients.max()

    distances_x = np.array(distances_x)/total_x
    distances_y = np.array(distances_y)/total_y
    average_x = np.average(distances_x)
    average_y = np.average(distances_y)

    average_slope = np.average(slopes)
    average_coeffients = np.average(coeffients)

    #p = slopes * distances_y * coeffients
    p = slopes * distances_y
    #cost = (average_x * average_y) / (average_slope)
    cost = average_x / np.average(p)

    return average_x, average_y, average_slope, average_coeffients, cost


def accuracy_trace(points: np.ndarray, knees: np.ndarray) -&gt; tuple:
    &#34;&#34;&#34;Compute the accuracy heuristic for a set of knees.

    The heuristic is based on the average distance of X and Y axis, the slope and the R2.
    In this version it is used the points from the current knee to the previous.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes

    Returns:
        tuple: (average_x, average_y, average_slope, average_coeffients, cost)
    &#34;&#34;&#34;
    x = points[:, 0]
    y = points[:, 1]

    distances_x = []
    distances_y = []
    slopes = []
    coeffients = []

    total_x = math.fabs(x[-1] - x[0])
    total_y = math.fabs(y[-1] - y[0])

    previous_knee_x = x[knees[0]]
    previous_knee_y = y[knees[0]]

    delta_x = x[0] - previous_knee_x
    delta_y = y[0] - previous_knee_y
    distances_x.append(math.fabs(delta_x))
    distances_y.append(math.fabs(delta_y))

    coef = lf.linear_fit(x[0:knees[0]+1], y[0:knees[0]+1])
    r2 = lf.linear_r2(x[0:knees[0]+1], y[0:knees[0]+1], coef)
    coeffients.append(r2)
    _, slope = coef
    slopes.append(math.fabs(slope))

    for i in range(1, len(knees)):
        knee_x = x[knees[i]]
        knee_y = y[knees[i]]

        delta_x = previous_knee_x - knee_x
        delta_y = previous_knee_y - knee_y

        coef = lf.linear_fit(x[knees[i-1]:knees[i]+1],
                             y[knees[i-1]:knees[i]+1])
        r2 = lf.linear_r2(x[knees[i-1]:knees[i]+1],
                          y[knees[i-1]:knees[i]+1], coef)

        distances_x.append(math.fabs(delta_x))
        distances_y.append(math.fabs(delta_y))
        _, slope = coef
        slopes.append(math.fabs(slope))
        coeffients.append(r2)

        previous_knee_x = knee_x
        previous_knee_y = knee_y

    distances_x = np.array(distances_x)/total_x
    distances_y = np.array(distances_y)/total_y
    slopes = np.array(slopes)
    slopes = slopes/slopes.max()

    coeffients = np.array(coeffients)
    coeffients = coeffients/coeffients.max()

    coeffients[coeffients &lt; 0] = 0.0
    p = slopes * distances_y * coeffients
    #p = slopes * distances_y

    average_x = np.average(distances_x)
    average_y = np.average(distances_y)
    average_slope = np.average(slopes)
    average_coeffients = np.average(coeffients)

    cost = average_x / np.average(p)

    return average_x, average_y, average_slope, average_coeffients, cost


def mae(points: np.ndarray, knees: np.ndarray, expected: np.ndarray, s: Strategy = Strategy.expected) -&gt; float:
    &#34;&#34;&#34;
    Estimates the worst case Mean Absolute Error (MAE) for the given
    knee and expected points.

    Suppports different size arrays, and estimates the MAE based 
    on the worst case.
    It uses the euclidean distance to find the closer points,
    and computes the error based on the closest point.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        expected (np.ndarray): numpy array with the expected knee points (x, y)
        s (Strategy): enum that controls the point matching (default Strategy.expected)

    Returns:
        float: the worst case MAE
    &#34;&#34;&#34;
    # get the knee points
    knee_points = points[knees]

    error = 0.0

    if s is Strategy.knees:
        a = knee_points
        b = expected
    elif s is Strategy.expected:
        a = expected
        b = knee_points
    elif s is Strategy.best:
        if len(expected) &lt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected
    else:
        if len(expected) &gt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected

    for p in a:
        distances = np.linalg.norm(b-p, axis=1)
        idx = np.argmin(distances)
        error += np.sum(np.abs(p-b[idx]))

    return error / (len(a)*2.0)


def mse(points: np.ndarray, knees: np.ndarray, expected: np.ndarray, s: Strategy = Strategy.expected) -&gt; float:
    &#34;&#34;&#34;
    Estimates the worst case Mean Squared Error (MSE) for the given
    knee and expected points.

    Suppports different size arrays, and estimates the MSE based 
    on the worst case.
    It uses the euclidean distance to find the closer points,
    and computes the error based on the closest point.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        expected (np.ndarray): numpy array with the expected knee points (x, y)
        s (Strategy): enum that controls the point matching (default Strategy.expected)

    Returns:
        float: the worst case MSE
    &#34;&#34;&#34;
    # get the knee points
    knee_points = points[knees]

    error = 0.0

    if s is Strategy.knees:
        a = knee_points
        b = expected
    elif s is Strategy.expected:
        a = expected
        b = knee_points
    elif s is Strategy.best:
        if len(expected) &lt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected
    else:
        if len(expected) &gt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected

    for p in a:
        distances = np.linalg.norm(b-p, axis=1)
        idx = np.argmin(distances)
        error += np.sum(np.square(p-b[idx]))

    return error / (len(a)*2.0)


def rmse(points: np.ndarray, knees: np.ndarray, expected: np.ndarray, s: Strategy = Strategy.expected) -&gt; float:
    &#34;&#34;&#34;
    Estimates the worst case Root Mean Squared Error (RMSE) for the given
    knee and expected points.

    Suppports different size arrays, and estimates the RMSE based 
    on the worst case.
    It uses the euclidean distance to find the closer points,
    and computes the error based on the closest point.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        expected (np.ndarray): numpy array with the expected knee points (x, y)
        s (Strategy): enum that controls the point matching (default Strategy.expected)

    Returns:
        float: the worst case RMSE
    &#34;&#34;&#34;
    return math.sqrt(mse(points, knees, expected, s))


def rmspe(points: np.ndarray, knees: np.ndarray, expected: np.ndarray, s: Strategy = Strategy.expected, eps: float = 1e-16) -&gt; float:
    &#34;&#34;&#34;
    Estimates the worst case Root Mean Squared Percentage Error (RMSPE) for the given knee and expected points.

    Suppports different size arrays, and estimates the RMSPE based on the worst case.
    It uses the euclidean distance to find the closer points, and computes the error based on the closest point.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        expected (np.ndarray): numpy array with the expected knee points (x, y)
        s (Strategy): enum that controls the point matching (default Strategy.expected)
        eps (float): eps value to prevent division by zero (default: 1E-16)

    Returns:
        float: the worst case RMSPE
    &#34;&#34;&#34;
    # get the knee points
    knee_points = points[knees]

    if s is Strategy.knees:
        a = knee_points
        b = expected
    elif s is Strategy.expected:
        a = expected
        b = knee_points
    elif s is Strategy.best:
        if len(expected) &lt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected
    else:
        if len(expected) &gt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected

    errors = []

    for p in a:
        distances = np.linalg.norm(b-p, axis=1)
        idx = np.argmin(distances)
        e = (p - b[idx]) / (p + eps)
        errors.extend(e)
    errors = np.array(errors)

    return np.sqrt(np.mean(np.square(errors)))


def cm(points: np.ndarray, knees: np.ndarray, expected: np.ndarray, t: float = 0.01) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Computes the Confusion Matrix based on the knees and expected points.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        expected (np.ndarray): numpy array with the expected knee points (x, y)
        t (float): the maximum allowed distance in percentage (default 0.01)

    Returns:
        np.ndarray: the confusion matrix
    &#34;&#34;&#34;

    #dx = math.fabs(points[-1][0] - points[0][0])
    max_x, _ = points.max(axis=0)
    min_x, _ = points.min(axis=0)
    dx = math.fabs(max_x - min_x)
    used_knees = []
    knees_points_x = points[knees][:, 0]
    tp = fn = fp = tn = 0
    for px, _ in expected:
        distances = np.fabs(knees_points_x - px)/dx
        idx = np.argmin(distances)
        #logger.info(f&#34;{px} / {idx} / {distances[idx]} = {distances[idx] &lt;= t}&#34;)
        if distances[idx] &lt;= t and idx not in used_knees:
            tp += 1
            used_knees.append(idx)
        else:
            fn += 1
    fp = max(len(knees) - tp, 0)
    tn = len(points) - (tp+fp+fn)

    return np.array([[tp, fp], [fn, tn]])


def accuracy(cm: np.ndarray) -&gt; float:
    &#34;&#34;&#34;
    Computes accuracy based on a Confusion Matrix.

    Args:
        cm (np.ndarray): the confusion matrix

    Returns:
        float: the accuracy
    &#34;&#34;&#34;

    tp, fp = cm[0]
    fn, tn = cm[1]

    return (tp+tn)/(tp+tn+fp+fn)


def f1score(cm: np.ndarray) -&gt; float:
    &#34;&#34;&#34;
    Computes F1-Score based on a Confusion Matrix.

    Args:
        cm (np.ndarray): the confusion matrix

    Returns:
        float: the F1-Score
    &#34;&#34;&#34;

    tp, fp = cm[0]
    fn, _ = cm[1]

    return (2.0*tp)/(2*tp+fp+fn)


def mcc(cm: np.ndarray) -&gt; float:
    &#34;&#34;&#34;
    Computes Matthews Correlation Coefficient (MCC) based on a Confusion Matrix.

    Args:
        cm (np.ndarray): the confusion matrix

    Returns:
        float: the mcc
    &#34;&#34;&#34;

    tp, fp = cm[0]
    fn, tn = cm[1]

    n = tp*tn - fp*fn
    d = math.sqrt((tp+fp)*(tp+fn)*(tn+fp)*(tn+fn))

    return n/d</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="knee.evaluation.accuracy"><code class="name flex">
<span>def <span class="ident">accuracy</span></span>(<span>cm:Â numpy.ndarray) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes accuracy based on a Confusion Matrix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cm</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>the confusion matrix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the accuracy</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accuracy(cm: np.ndarray) -&gt; float:
    &#34;&#34;&#34;
    Computes accuracy based on a Confusion Matrix.

    Args:
        cm (np.ndarray): the confusion matrix

    Returns:
        float: the accuracy
    &#34;&#34;&#34;

    tp, fp = cm[0]
    fn, tn = cm[1]

    return (tp+tn)/(tp+tn+fp+fn)</code></pre>
</details>
</dd>
<dt id="knee.evaluation.accuracy_knee"><code class="name flex">
<span>def <span class="ident">accuracy_knee</span></span>(<span>points:Â numpy.ndarray, knees:Â numpy.ndarray, t:Â floatÂ =Â 0.9) â>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the accuracy heuristic for a set of knees.</p>
<p>The heuristic is based on the average distance of X and Y axis, the slope and the R2.
In this version it is used the left neighbourhood of the knee.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>knees</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>knees indexes</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>R2 threshold (default 0.9)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(average_x, average_y, average_slope, average_coeffients, cost)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accuracy_knee(points: np.ndarray, knees: np.ndarray, t: float = 0.9) -&gt; tuple:
    &#34;&#34;&#34;Compute the accuracy heuristic for a set of knees.

    The heuristic is based on the average distance of X and Y axis, the slope and the R2.
    In this version it is used the left neighbourhood of the knee.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        t (float): R2 threshold (default 0.9)

    Returns:
        tuple: (average_x, average_y, average_slope, average_coeffients, cost)
    &#34;&#34;&#34;
    x = points[:, 0]
    y = points[:, 1]

    total_x = math.fabs(x[-1] - x[0])
    total_y = math.fabs(y[-1] - y[0])

    distances_x = []
    distances_y = []
    slopes = []
    coeffients = []

    previous_knee = 0
    for i in range(len(knees)):
        idx, r2, slope = get_neighbourhood_fast(x, y, knees[i], previous_knee)

        delta_x = x[idx] - x[knees[i]]
        delta_y = y[idx] - y[knees[i]]

        distances_x.append(math.fabs(delta_x))
        distances_y.append(math.fabs(delta_y))
        slopes.append(math.fabs(slope))
        coeffients.append(r2)

        previous_knee = knees[i]

    slopes = np.array(slopes)
    slopes = slopes/slopes.max()

    coeffients = np.array(coeffients)
    coeffients = coeffients/coeffients.max()

    distances_x = np.array(distances_x)/total_x
    distances_y = np.array(distances_y)/total_y
    average_x = np.average(distances_x)
    average_y = np.average(distances_y)

    average_slope = np.average(slopes)
    average_coeffients = np.average(coeffients)

    #p = slopes * distances_y * coeffients
    p = slopes * distances_y
    #cost = (average_x * average_y) / (average_slope)
    cost = average_x / np.average(p)

    return average_x, average_y, average_slope, average_coeffients, cost</code></pre>
</details>
</dd>
<dt id="knee.evaluation.accuracy_trace"><code class="name flex">
<span>def <span class="ident">accuracy_trace</span></span>(<span>points:Â numpy.ndarray, knees:Â numpy.ndarray) â>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the accuracy heuristic for a set of knees.</p>
<p>The heuristic is based on the average distance of X and Y axis, the slope and the R2.
In this version it is used the points from the current knee to the previous.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>knees</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>knees indexes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(average_x, average_y, average_slope, average_coeffients, cost)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accuracy_trace(points: np.ndarray, knees: np.ndarray) -&gt; tuple:
    &#34;&#34;&#34;Compute the accuracy heuristic for a set of knees.

    The heuristic is based on the average distance of X and Y axis, the slope and the R2.
    In this version it is used the points from the current knee to the previous.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes

    Returns:
        tuple: (average_x, average_y, average_slope, average_coeffients, cost)
    &#34;&#34;&#34;
    x = points[:, 0]
    y = points[:, 1]

    distances_x = []
    distances_y = []
    slopes = []
    coeffients = []

    total_x = math.fabs(x[-1] - x[0])
    total_y = math.fabs(y[-1] - y[0])

    previous_knee_x = x[knees[0]]
    previous_knee_y = y[knees[0]]

    delta_x = x[0] - previous_knee_x
    delta_y = y[0] - previous_knee_y
    distances_x.append(math.fabs(delta_x))
    distances_y.append(math.fabs(delta_y))

    coef = lf.linear_fit(x[0:knees[0]+1], y[0:knees[0]+1])
    r2 = lf.linear_r2(x[0:knees[0]+1], y[0:knees[0]+1], coef)
    coeffients.append(r2)
    _, slope = coef
    slopes.append(math.fabs(slope))

    for i in range(1, len(knees)):
        knee_x = x[knees[i]]
        knee_y = y[knees[i]]

        delta_x = previous_knee_x - knee_x
        delta_y = previous_knee_y - knee_y

        coef = lf.linear_fit(x[knees[i-1]:knees[i]+1],
                             y[knees[i-1]:knees[i]+1])
        r2 = lf.linear_r2(x[knees[i-1]:knees[i]+1],
                          y[knees[i-1]:knees[i]+1], coef)

        distances_x.append(math.fabs(delta_x))
        distances_y.append(math.fabs(delta_y))
        _, slope = coef
        slopes.append(math.fabs(slope))
        coeffients.append(r2)

        previous_knee_x = knee_x
        previous_knee_y = knee_y

    distances_x = np.array(distances_x)/total_x
    distances_y = np.array(distances_y)/total_y
    slopes = np.array(slopes)
    slopes = slopes/slopes.max()

    coeffients = np.array(coeffients)
    coeffients = coeffients/coeffients.max()

    coeffients[coeffients &lt; 0] = 0.0
    p = slopes * distances_y * coeffients
    #p = slopes * distances_y

    average_x = np.average(distances_x)
    average_y = np.average(distances_y)
    average_slope = np.average(slopes)
    average_coeffients = np.average(coeffients)

    cost = average_x / np.average(p)

    return average_x, average_y, average_slope, average_coeffients, cost</code></pre>
</details>
</dd>
<dt id="knee.evaluation.cm"><code class="name flex">
<span>def <span class="ident">cm</span></span>(<span>points:Â numpy.ndarray, knees:Â numpy.ndarray, expected:Â numpy.ndarray, t:Â floatÂ =Â 0.01) â>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the Confusion Matrix based on the knees and expected points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>knees</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>knees indexes</dd>
<dt><strong><code>expected</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the expected knee points (x, y)</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>the maximum allowed distance in percentage (default 0.01)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>the confusion matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cm(points: np.ndarray, knees: np.ndarray, expected: np.ndarray, t: float = 0.01) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Computes the Confusion Matrix based on the knees and expected points.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        expected (np.ndarray): numpy array with the expected knee points (x, y)
        t (float): the maximum allowed distance in percentage (default 0.01)

    Returns:
        np.ndarray: the confusion matrix
    &#34;&#34;&#34;

    #dx = math.fabs(points[-1][0] - points[0][0])
    max_x, _ = points.max(axis=0)
    min_x, _ = points.min(axis=0)
    dx = math.fabs(max_x - min_x)
    used_knees = []
    knees_points_x = points[knees][:, 0]
    tp = fn = fp = tn = 0
    for px, _ in expected:
        distances = np.fabs(knees_points_x - px)/dx
        idx = np.argmin(distances)
        #logger.info(f&#34;{px} / {idx} / {distances[idx]} = {distances[idx] &lt;= t}&#34;)
        if distances[idx] &lt;= t and idx not in used_knees:
            tp += 1
            used_knees.append(idx)
        else:
            fn += 1
    fp = max(len(knees) - tp, 0)
    tn = len(points) - (tp+fp+fn)

    return np.array([[tp, fp], [fn, tn]])</code></pre>
</details>
</dd>
<dt id="knee.evaluation.f1score"><code class="name flex">
<span>def <span class="ident">f1score</span></span>(<span>cm:Â numpy.ndarray) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes F1-Score based on a Confusion Matrix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cm</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>the confusion matrix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the F1-Score</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f1score(cm: np.ndarray) -&gt; float:
    &#34;&#34;&#34;
    Computes F1-Score based on a Confusion Matrix.

    Args:
        cm (np.ndarray): the confusion matrix

    Returns:
        float: the F1-Score
    &#34;&#34;&#34;

    tp, fp = cm[0]
    fn, _ = cm[1]

    return (2.0*tp)/(2*tp+fp+fn)</code></pre>
</details>
</dd>
<dt id="knee.evaluation.get_neighbourhood"><code class="name flex">
<span>def <span class="ident">get_neighbourhood</span></span>(<span>x:Â numpy.ndarray, y:Â numpy.ndarray, a:Â int, b:Â int, t:Â floatÂ =Â 0.9) â>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Get the neighbourhood (closest points) from a to b.</p>
<p>The neighbourhood is defined as the longest straitgh line (defined by R2).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>the value of the points in the x axis coordinates</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>the value of the points in the y axis coordinates</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>int</code></dt>
<dd>the initial point of the search</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>the left limit of the search</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>R2 threshold (default 0.9)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(neighbourhood index, r2, slope)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbourhood(x: np.ndarray, y: np.ndarray, a: int, b: int, t: float = 0.9) -&gt; tuple:
    &#34;&#34;&#34;
    Get the neighbourhood (closest points) from a to b.

    The neighbourhood is defined as the longest straitgh line (defined by R2).

    Args:
        x (np.ndarray): the value of the points in the x axis coordinates
        y (np.ndarray): the value of the points in the y axis coordinates
        a (int): the initial point of the search
        b (int): the left limit of the search
        t (float): R2 threshold (default 0.9)

    Returns:
        tuple: (neighbourhood index, r2, slope)
    &#34;&#34;&#34;

    r2 = 1.0
    i = a - 1
    _, slope = lf.linear_fit(x[i:a+1], y[i:a+1])

    while r2 &gt; t and i &gt; b:
        # print(&#39;.&#39;)
        previous_res = (i, r2, slope)
        i -= 1
        coef = lf.linear_fit(x[i:a+1], y[i:a+1])
        r2 = lf.linear_r2(x[i:a+1], y[i:a+1], coef)
        _, slope = coef
        #print(f&#39;{i} -&gt; {r2}&#39;)

    if r2 &gt; t:
        return i, r2, slope
    else:
        return previous_res</code></pre>
</details>
</dd>
<dt id="knee.evaluation.get_neighbourhood_binary"><code class="name flex">
<span>def <span class="ident">get_neighbourhood_binary</span></span>(<span>x:Â numpy.ndarray, y:Â numpy.ndarray, a:Â int, b:Â int, t=0.9) â>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Get the index of the point within the range [b, a] where the R2 is close to the threshold.</p>
<p>This version uses a inaccurate binary search to speedup the search.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>the value of the points in the x axis coordinates</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>the value of the points in the y axis coordinates</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>int</code></dt>
<dd>the initial point of the search</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>the left limit of the search</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>R2 threshold (default 0.9)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>index of the point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbourhood_binary(x: np.ndarray, y: np.ndarray, a: int, b: int, t=0.9) -&gt; int:
    &#34;&#34;&#34;
    Get the index of the point within the range [b, a] where the R2 is close to the threshold.

    This version uses a inaccurate binary search to speedup the search.

    Args:
        x (np.ndarray): the value of the points in the x axis coordinates
        y (np.ndarray): the value of the points in the y axis coordinates
        a (int): the initial point of the search
        b (int): the left limit of the search
        t (float): R2 threshold (default 0.9)

    Returns:
        int: index of the point
    &#34;&#34;&#34;

    i = b
    right = a

    while abs(i-right) &gt; 1:
        coef = lf.linear_fit(x[i:a+1], y[i:a+1])
        r2 = lf.linear_r2(x[i:a+1], y[i:a+1], coef)

        if r2 &lt; t:
            i = int((i+right)/2.0)
        else:
            right = i
            i = int((b+right)/2.0)

    return i</code></pre>
</details>
</dd>
<dt id="knee.evaluation.get_neighbourhood_fast"><code class="name flex">
<span>def <span class="ident">get_neighbourhood_fast</span></span>(<span>x:Â numpy.ndarray, y:Â numpy.ndarray, a:Â int, b:Â int, t:Â floatÂ =Â 0.9) â>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Get the neighbourhood (closest points) from a to b.</p>
<p>The neighbourhood is defined as the longest straitgh line (defined by R2).
This version uses a inaccurate binary search to speedup the search.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>the value of the points in the x axis coordinates</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>the value of the points in the y axis coordinates</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>int</code></dt>
<dd>the initial point of the search</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>the left limit of the search</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>R2 threshold (default 0.9)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(neighbourhood index, r2, slope)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbourhood_fast(x: np.ndarray, y: np.ndarray, a: int, b: int, t: float = 0.9) -&gt; tuple:
    &#34;&#34;&#34;
    Get the neighbourhood (closest points) from a to b.

    The neighbourhood is defined as the longest straitgh line (defined by R2).
    This version uses a inaccurate binary search to speedup the search.

    Args:
        x (np.ndarray): the value of the points in the x axis coordinates
        y (np.ndarray): the value of the points in the y axis coordinates
        a (int): the initial point of the search
        b (int): the left limit of the search
        t (float): R2 threshold (default 0.9)

    Returns:
        tuple: (neighbourhood index, r2, slope)
    &#34;&#34;&#34;
    # speedup when the search using an inaccurate binary search
    i = get_neighbourhood_binary(x, y, a, b, t)
    b, slope = lf.linear_fit(x[i:a+1], y[i:a+1])
    r2 = lf.linear_r2(x[i:a+1], y[i:a+1], (b, slope))
    previous_res = (i, r2, slope)

    # Linear search to improve accuracy
    while r2 &lt; t and i &lt; a:
        i += 1
        coef = lf.linear_fit(x[i:a+1], y[i:a+1])
        r2 = lf.linear_r2(x[i:a+1], y[i:a+1], coef)
        _, slope = coef
        previous_res = (i, r2, slope)

    return previous_res</code></pre>
</details>
</dd>
<dt id="knee.evaluation.get_neighbourhood_fast_points"><code class="name flex">
<span>def <span class="ident">get_neighbourhood_fast_points</span></span>(<span>points:Â numpy.ndarray, a:Â int, b:Â int, t:Â float) â>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Get the neighbourhood (closest points) from a to b.</p>
<p>The neighbourhood is defined as the longest straitgh line (defined by R2).
This version uses a inaccurate binary search to speedup the search.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>int</code></dt>
<dd>the initial point of the search</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>the left limit of the search</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>R2 threshold</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(neighbourhood index, r2, slope)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbourhood_fast_points(points: np.ndarray, a: int, b: int, t: float) -&gt; tuple:
    &#34;&#34;&#34;Get the neighbourhood (closest points) from a to b.

    The neighbourhood is defined as the longest straitgh line (defined by R2).
    This version uses a inaccurate binary search to speedup the search.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        a (int): the initial point of the search
        b (int): the left limit of the search
        t (float): R2 threshold

    Returns:
        tuple: (neighbourhood index, r2, slope)
    &#34;&#34;&#34;

    x = points[:, 0]
    y = points[:, 1]
    return get_neighbourhood_fast(x, y, a, b, t)</code></pre>
</details>
</dd>
<dt id="knee.evaluation.get_neighbourhood_points"><code class="name flex">
<span>def <span class="ident">get_neighbourhood_points</span></span>(<span>points:Â numpy.ndarray, a:Â int, b:Â int, t:Â float) â>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Get the neighbourhood (closest points) from a to b.</p>
<p>The neighbourhood is defined as the longest straitgh line (defined by R2).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>int</code></dt>
<dd>the initial point of the search</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>the left limit of the search</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>R2 threshold</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(neighbourhood index, r2, slope)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbourhood_points(points: np.ndarray, a: int, b: int, t: float) -&gt; tuple:
    &#34;&#34;&#34;Get the neighbourhood (closest points) from a to b.

    The neighbourhood is defined as the longest straitgh line (defined by R2).

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        a (int): the initial point of the search
        b (int): the left limit of the search
        t (float): R2 threshold

    Returns:
        tuple: (neighbourhood index, r2, slope)
    &#34;&#34;&#34;

    x = points[:, 0]
    y = points[:, 1]
    return get_neighbourhood(x, y, a, b, t)</code></pre>
</details>
</dd>
<dt id="knee.evaluation.mae"><code class="name flex">
<span>def <span class="ident">mae</span></span>(<span>points:Â numpy.ndarray, knees:Â numpy.ndarray, expected:Â numpy.ndarray, s:Â <a title="knee.evaluation.Strategy" href="#knee.evaluation.Strategy">Strategy</a>Â =Â expected) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Estimates the worst case Mean Absolute Error (MAE) for the given
knee and expected points.</p>
<p>Suppports different size arrays, and estimates the MAE based
on the worst case.
It uses the euclidean distance to find the closer points,
and computes the error based on the closest point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>knees</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>knees indexes</dd>
<dt><strong><code>expected</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the expected knee points (x, y)</dd>
<dt><strong><code>s</code></strong> :&ensp;<code><a title="knee.evaluation.Strategy" href="#knee.evaluation.Strategy">Strategy</a></code></dt>
<dd>enum that controls the point matching (default Strategy.expected)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the worst case MAE</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mae(points: np.ndarray, knees: np.ndarray, expected: np.ndarray, s: Strategy = Strategy.expected) -&gt; float:
    &#34;&#34;&#34;
    Estimates the worst case Mean Absolute Error (MAE) for the given
    knee and expected points.

    Suppports different size arrays, and estimates the MAE based 
    on the worst case.
    It uses the euclidean distance to find the closer points,
    and computes the error based on the closest point.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        expected (np.ndarray): numpy array with the expected knee points (x, y)
        s (Strategy): enum that controls the point matching (default Strategy.expected)

    Returns:
        float: the worst case MAE
    &#34;&#34;&#34;
    # get the knee points
    knee_points = points[knees]

    error = 0.0

    if s is Strategy.knees:
        a = knee_points
        b = expected
    elif s is Strategy.expected:
        a = expected
        b = knee_points
    elif s is Strategy.best:
        if len(expected) &lt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected
    else:
        if len(expected) &gt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected

    for p in a:
        distances = np.linalg.norm(b-p, axis=1)
        idx = np.argmin(distances)
        error += np.sum(np.abs(p-b[idx]))

    return error / (len(a)*2.0)</code></pre>
</details>
</dd>
<dt id="knee.evaluation.mcc"><code class="name flex">
<span>def <span class="ident">mcc</span></span>(<span>cm:Â numpy.ndarray) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes Matthews Correlation Coefficient (MCC) based on a Confusion Matrix.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cm</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>the confusion matrix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the mcc</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mcc(cm: np.ndarray) -&gt; float:
    &#34;&#34;&#34;
    Computes Matthews Correlation Coefficient (MCC) based on a Confusion Matrix.

    Args:
        cm (np.ndarray): the confusion matrix

    Returns:
        float: the mcc
    &#34;&#34;&#34;

    tp, fp = cm[0]
    fn, tn = cm[1]

    n = tp*tn - fp*fn
    d = math.sqrt((tp+fp)*(tp+fn)*(tn+fp)*(tn+fn))

    return n/d</code></pre>
</details>
</dd>
<dt id="knee.evaluation.mse"><code class="name flex">
<span>def <span class="ident">mse</span></span>(<span>points:Â numpy.ndarray, knees:Â numpy.ndarray, expected:Â numpy.ndarray, s:Â <a title="knee.evaluation.Strategy" href="#knee.evaluation.Strategy">Strategy</a>Â =Â expected) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Estimates the worst case Mean Squared Error (MSE) for the given
knee and expected points.</p>
<p>Suppports different size arrays, and estimates the MSE based
on the worst case.
It uses the euclidean distance to find the closer points,
and computes the error based on the closest point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>knees</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>knees indexes</dd>
<dt><strong><code>expected</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the expected knee points (x, y)</dd>
<dt><strong><code>s</code></strong> :&ensp;<code><a title="knee.evaluation.Strategy" href="#knee.evaluation.Strategy">Strategy</a></code></dt>
<dd>enum that controls the point matching (default Strategy.expected)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the worst case MSE</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mse(points: np.ndarray, knees: np.ndarray, expected: np.ndarray, s: Strategy = Strategy.expected) -&gt; float:
    &#34;&#34;&#34;
    Estimates the worst case Mean Squared Error (MSE) for the given
    knee and expected points.

    Suppports different size arrays, and estimates the MSE based 
    on the worst case.
    It uses the euclidean distance to find the closer points,
    and computes the error based on the closest point.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        expected (np.ndarray): numpy array with the expected knee points (x, y)
        s (Strategy): enum that controls the point matching (default Strategy.expected)

    Returns:
        float: the worst case MSE
    &#34;&#34;&#34;
    # get the knee points
    knee_points = points[knees]

    error = 0.0

    if s is Strategy.knees:
        a = knee_points
        b = expected
    elif s is Strategy.expected:
        a = expected
        b = knee_points
    elif s is Strategy.best:
        if len(expected) &lt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected
    else:
        if len(expected) &gt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected

    for p in a:
        distances = np.linalg.norm(b-p, axis=1)
        idx = np.argmin(distances)
        error += np.sum(np.square(p-b[idx]))

    return error / (len(a)*2.0)</code></pre>
</details>
</dd>
<dt id="knee.evaluation.rmse"><code class="name flex">
<span>def <span class="ident">rmse</span></span>(<span>points:Â numpy.ndarray, knees:Â numpy.ndarray, expected:Â numpy.ndarray, s:Â <a title="knee.evaluation.Strategy" href="#knee.evaluation.Strategy">Strategy</a>Â =Â expected) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Estimates the worst case Root Mean Squared Error (RMSE) for the given
knee and expected points.</p>
<p>Suppports different size arrays, and estimates the RMSE based
on the worst case.
It uses the euclidean distance to find the closer points,
and computes the error based on the closest point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>knees</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>knees indexes</dd>
<dt><strong><code>expected</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the expected knee points (x, y)</dd>
<dt><strong><code>s</code></strong> :&ensp;<code><a title="knee.evaluation.Strategy" href="#knee.evaluation.Strategy">Strategy</a></code></dt>
<dd>enum that controls the point matching (default Strategy.expected)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the worst case RMSE</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmse(points: np.ndarray, knees: np.ndarray, expected: np.ndarray, s: Strategy = Strategy.expected) -&gt; float:
    &#34;&#34;&#34;
    Estimates the worst case Root Mean Squared Error (RMSE) for the given
    knee and expected points.

    Suppports different size arrays, and estimates the RMSE based 
    on the worst case.
    It uses the euclidean distance to find the closer points,
    and computes the error based on the closest point.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        expected (np.ndarray): numpy array with the expected knee points (x, y)
        s (Strategy): enum that controls the point matching (default Strategy.expected)

    Returns:
        float: the worst case RMSE
    &#34;&#34;&#34;
    return math.sqrt(mse(points, knees, expected, s))</code></pre>
</details>
</dd>
<dt id="knee.evaluation.rmspe"><code class="name flex">
<span>def <span class="ident">rmspe</span></span>(<span>points:Â numpy.ndarray, knees:Â numpy.ndarray, expected:Â numpy.ndarray, s:Â <a title="knee.evaluation.Strategy" href="#knee.evaluation.Strategy">Strategy</a>Â =Â expected, eps:Â floatÂ =Â 1e-16) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Estimates the worst case Root Mean Squared Percentage Error (RMSPE) for the given knee and expected points.</p>
<p>Suppports different size arrays, and estimates the RMSPE based on the worst case.
It uses the euclidean distance to find the closer points, and computes the error based on the closest point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the points (x, y)</dd>
<dt><strong><code>knees</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>knees indexes</dd>
<dt><strong><code>expected</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>numpy array with the expected knee points (x, y)</dd>
<dt><strong><code>s</code></strong> :&ensp;<code><a title="knee.evaluation.Strategy" href="#knee.evaluation.Strategy">Strategy</a></code></dt>
<dd>enum that controls the point matching (default Strategy.expected)</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code></dt>
<dd>eps value to prevent division by zero (default: 1E-16)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the worst case RMSPE</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmspe(points: np.ndarray, knees: np.ndarray, expected: np.ndarray, s: Strategy = Strategy.expected, eps: float = 1e-16) -&gt; float:
    &#34;&#34;&#34;
    Estimates the worst case Root Mean Squared Percentage Error (RMSPE) for the given knee and expected points.

    Suppports different size arrays, and estimates the RMSPE based on the worst case.
    It uses the euclidean distance to find the closer points, and computes the error based on the closest point.

    Args:
        points (np.ndarray): numpy array with the points (x, y)
        knees (np.ndarray): knees indexes
        expected (np.ndarray): numpy array with the expected knee points (x, y)
        s (Strategy): enum that controls the point matching (default Strategy.expected)
        eps (float): eps value to prevent division by zero (default: 1E-16)

    Returns:
        float: the worst case RMSPE
    &#34;&#34;&#34;
    # get the knee points
    knee_points = points[knees]

    if s is Strategy.knees:
        a = knee_points
        b = expected
    elif s is Strategy.expected:
        a = expected
        b = knee_points
    elif s is Strategy.best:
        if len(expected) &lt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected
    else:
        if len(expected) &gt;= len(knee_points):
            a = expected
            b = knee_points
        else:
            a = knee_points
            b = expected

    errors = []

    for p in a:
        distances = np.linalg.norm(b-p, axis=1)
        idx = np.argmin(distances)
        e = (p - b[idx]) / (p + eps)
        errors.extend(e)
    errors = np.array(errors)

    return np.sqrt(np.mean(np.square(errors)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="knee.evaluation.Strategy"><code class="flex name class">
<span>class <span class="ident">Strategy</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum data type that represents the strategy of MAE, MSE and RMSE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Strategy(enum.Enum):
    &#34;&#34;&#34;
    Enum data type that represents the strategy of MAE, MSE and RMSE
    &#34;&#34;&#34;
    knees = &#39;knees&#39;
    expected = &#39;expected&#39;
    best = &#39;best&#39;
    worst = &#39;worst&#39;

    def __str__(self):
        return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="knee.evaluation.Strategy.best"><code class="name">var <span class="ident">best</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="knee.evaluation.Strategy.expected"><code class="name">var <span class="ident">expected</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="knee.evaluation.Strategy.knees"><code class="name">var <span class="ident">knees</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="knee.evaluation.Strategy.worst"><code class="name">var <span class="ident">worst</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="knee" href="index.html">knee</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="knee.evaluation.accuracy" href="#knee.evaluation.accuracy">accuracy</a></code></li>
<li><code><a title="knee.evaluation.accuracy_knee" href="#knee.evaluation.accuracy_knee">accuracy_knee</a></code></li>
<li><code><a title="knee.evaluation.accuracy_trace" href="#knee.evaluation.accuracy_trace">accuracy_trace</a></code></li>
<li><code><a title="knee.evaluation.cm" href="#knee.evaluation.cm">cm</a></code></li>
<li><code><a title="knee.evaluation.f1score" href="#knee.evaluation.f1score">f1score</a></code></li>
<li><code><a title="knee.evaluation.get_neighbourhood" href="#knee.evaluation.get_neighbourhood">get_neighbourhood</a></code></li>
<li><code><a title="knee.evaluation.get_neighbourhood_binary" href="#knee.evaluation.get_neighbourhood_binary">get_neighbourhood_binary</a></code></li>
<li><code><a title="knee.evaluation.get_neighbourhood_fast" href="#knee.evaluation.get_neighbourhood_fast">get_neighbourhood_fast</a></code></li>
<li><code><a title="knee.evaluation.get_neighbourhood_fast_points" href="#knee.evaluation.get_neighbourhood_fast_points">get_neighbourhood_fast_points</a></code></li>
<li><code><a title="knee.evaluation.get_neighbourhood_points" href="#knee.evaluation.get_neighbourhood_points">get_neighbourhood_points</a></code></li>
<li><code><a title="knee.evaluation.mae" href="#knee.evaluation.mae">mae</a></code></li>
<li><code><a title="knee.evaluation.mcc" href="#knee.evaluation.mcc">mcc</a></code></li>
<li><code><a title="knee.evaluation.mse" href="#knee.evaluation.mse">mse</a></code></li>
<li><code><a title="knee.evaluation.rmse" href="#knee.evaluation.rmse">rmse</a></code></li>
<li><code><a title="knee.evaluation.rmspe" href="#knee.evaluation.rmspe">rmspe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="knee.evaluation.Strategy" href="#knee.evaluation.Strategy">Strategy</a></code></h4>
<ul class="">
<li><code><a title="knee.evaluation.Strategy.best" href="#knee.evaluation.Strategy.best">best</a></code></li>
<li><code><a title="knee.evaluation.Strategy.expected" href="#knee.evaluation.Strategy.expected">expected</a></code></li>
<li><code><a title="knee.evaluation.Strategy.knees" href="#knee.evaluation.Strategy.knees">knees</a></code></li>
<li><code><a title="knee.evaluation.Strategy.worst" href="#knee.evaluation.Strategy.worst">worst</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>