window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "knee", "modulename": "knee", "kind": "module", "doc": "<p>(Multi)Knee/Elbow point detection library</p>\n\n<p>Estimating the knee/elbow point in performance curves is a challenging task.\nHowever, most of the time these points represent ideal compromises between cost and performance.</p>\n\n<p>This library implements several well-known knee detection algorithms:</p>\n\n<ol>\n<li>Discrete Curvature </li>\n<li>DFDT</li>\n<li>Kneedle</li>\n<li>L-method</li>\n<li>Menger curvature</li>\n</ol>\n\n<p>Furthermore, the code in this library expands the ideas on these algorithms to \ndetect multi-knee/elbow points in complex curves.\nWe implemented a recursive method that allows each of the previously mentioned methods\nto detect multi-knee and elbow points.\nSome methods natively support multi-knee detection, such as:</p>\n\n<ol>\n<li>Kneedle</li>\n<li>Fusion</li>\n<li>Z-method</li>\n</ol>\n\n<p>Finally, we also implemented additional methods that help with knee detection tasks.\nAs a preprocessing step, we develop a custom RDP algorithm that reduced a discrete \nset of points while keeping the reconstruction error to a minimum.\nAs a post-processing step we implemented several algorithms:</p>\n\n<ol>\n<li>1D dimensional clustering, is used to merge close knee points</li>\n<li>Several filters out non-relevant knees</li>\n<li>Knee ranking algorithms that used several criteria to assess the quality of a knee point</li>\n</ol>\n"}, {"fullname": "knee.clustering", "modulename": "knee.clustering", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.clustering.single_linkage", "modulename": "knee.clustering", "qualname": "single_linkage", "kind": "function", "doc": "<p>Computes the 1D clustering of the input points.</p>\n\n<p>Efficient implementation that uses a single pass to compute the clusters.\nComputes the single linkage clustering based only on the x axis:\n$$\n    D(C_1, C_2) = \\min_{c_1  \\in C_1, c_2 \\in C_2} d(c_1, c_2)\n$$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  the threshold for merging (in percentage, default 0.01)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the clusters ids</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.clustering.complete_linkage", "modulename": "knee.clustering", "qualname": "complete_linkage", "kind": "function", "doc": "<p>Computes the 1D clustering of the input points.</p>\n\n<p>Efficient implementation that uses a single pass to compute the clusters.\nComputes the complete linkage clustering based only on the x axis:\n$$\n    D(C_1, C_2) = \\max_{c_1  \\in C_1, c_2 \\in C_2} d(c_1, c_2)\n$$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  the threshold for merging (in percentage, default 0.01)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the clusters ids</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.clustering.centroid_linkage", "modulename": "knee.clustering", "qualname": "centroid_linkage", "kind": "function", "doc": "<p>Computes the 1D clustering of the input points.</p>\n\n<p>Efficient implementation that uses a single pass to compute the clusters.\nComputes the centroid linkage clustering based only on the x axis:\n$$\n    D(C_1, C_2) = ||c_1 - c_2 ||\n$$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  the threshold for merging (in percentage, default 0.01)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the clusters ids</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.clustering.average_linkage", "modulename": "knee.clustering", "qualname": "average_linkage", "kind": "function", "doc": "<p>Computes the 1D clustering of the input points.</p>\n\n<p>Efficient implementation that uses a single pass to compute the clusters.\nComputes the average linkage clustering based only on the x axis:\n$$\n    D(C_1, C_2) = \\frac{1}{|C_1|}\\sum_{c_1 \\in C_1}d(c_1, C_2)\n$$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  the threshold for merging (in percentage, default 0.01)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the clusters ids</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.convex_hull", "modulename": "knee.convex_hull", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.convex_hull.ccw", "modulename": "knee.convex_hull", "qualname": "ccw", "kind": "function", "doc": "<p>Check if three points make a counter-clockwise turn.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>a (np.ndarray):</strong>  numpy array with a single point (x, y)</li>\n<li><strong>b (np.ndarray):</strong>  numpy array with a single point (x, y)</li>\n<li><strong>c (np.ndarray):</strong>  numpy array with a single point (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: $ \\gt 0$ if counter-clockwise; $ \\lt 0$ if clockwise; $ = 0$ if collinear</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">c</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.convex_hull.sort_points", "modulename": "knee.convex_hull", "qualname": "sort_points", "kind": "function", "doc": "<p>Sort and array of points on their distance to the first point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the sorted points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.convex_hull.graham_scan", "modulename": "knee.convex_hull", "qualname": "graham_scan", "kind": "function", "doc": "<p>Returns an array of indexes that make up the convex hull surrounding the points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the indexes of the hull points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.convex_hull.graham_scan_lower", "modulename": "knee.convex_hull", "qualname": "graham_scan_lower", "kind": "function", "doc": "<p>Returns an array of indexes that make up the lower convex hull.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the indexes of the hull points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.convex_hull.graham_scan_upper", "modulename": "knee.convex_hull", "qualname": "graham_scan_upper", "kind": "function", "doc": "<p>Returns an array of indexes that make up the upper convex hull.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the indexes of the hull points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.curvature", "modulename": "knee.curvature", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.curvature.knee", "modulename": "knee.curvature", "qualname": "knee", "kind": "function", "doc": "<p>Returns the index of the knee point based on the curvature equations:\n$$\nk = \\frac{|f''(x)|}{(1+[f'(2)]^2)^{\\frac{3}{2}}}\n$$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the index of the knee point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.curvature.multi_knee", "modulename": "knee.curvature", "qualname": "multi_knee", "kind": "function", "doc": "<p>Recursive knee point detection based on the curvature equations.</p>\n\n<p>It returns the knee points on the curve.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t1 (float):</strong>  coefficient of determination threshold (default 0.01)</li>\n<li><strong>t2 (int):</strong>  number of points threshold (default 3)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: knee points on the curve</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">t1</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>, </span><span class=\"param\"><span class=\"n\">t2</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.dfdt", "modulename": "knee.dfdt", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.dfdt.get_knee", "modulename": "knee.dfdt", "qualname": "get_knee", "kind": "function", "doc": "<p>Return the index of the knee point based on the DFDT method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the index of the knee point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.dfdt.get_knee_gradient", "modulename": "knee.dfdt", "qualname": "get_knee_gradient", "kind": "function", "doc": "<p>Return the index of the knee point based on the DFDT method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>gradient (np.ndarray):</strong>  the first order gradient of the trace points</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the index of the knee point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gradient</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.dfdt.knee", "modulename": "knee.dfdt", "qualname": "knee", "kind": "function", "doc": "<p>Returns the index of the knee point based on the DFDT method.</p>\n\n<p>It uses the iterative refinement  method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the index of the knee point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.dfdt.multi_knee", "modulename": "knee.dfdt", "qualname": "multi_knee", "kind": "function", "doc": "<p>Recursive knee point detection based on DFDT.</p>\n\n<p>It returns the knee points on the curve.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t1 (float):</strong>  coefficient of determination threshold (default 0.01)</li>\n<li><strong>t2 (int):</strong>  number of points threshold (default 3)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The knee points on the curve</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">t1</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>, </span><span class=\"param\"><span class=\"n\">t2</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation", "modulename": "knee.evaluation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.evaluation.Strategy", "modulename": "knee.evaluation", "qualname": "Strategy", "kind": "class", "doc": "<p>Enum data type that represents the strategy of MAE, MSE and RMSE</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.evaluation.Strategy.knees", "modulename": "knee.evaluation", "qualname": "Strategy.knees", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Strategy.knees: &#x27;knees&#x27;&gt;"}, {"fullname": "knee.evaluation.Strategy.expected", "modulename": "knee.evaluation", "qualname": "Strategy.expected", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Strategy.expected: &#x27;expected&#x27;&gt;"}, {"fullname": "knee.evaluation.Strategy.best", "modulename": "knee.evaluation", "qualname": "Strategy.best", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Strategy.best: &#x27;best&#x27;&gt;"}, {"fullname": "knee.evaluation.Strategy.worst", "modulename": "knee.evaluation", "qualname": "Strategy.worst", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Strategy.worst: &#x27;worst&#x27;&gt;"}, {"fullname": "knee.evaluation.get_neighbourhood_points", "modulename": "knee.evaluation", "qualname": "get_neighbourhood_points", "kind": "function", "doc": "<p>Get the neighbourhood (closest points) from a to b.</p>\n\n<p>The neighbourhood is defined as the longest straitgh line (defined by $R^2$).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>a (int):</strong>  the initial point of the search</li>\n<li><strong>b (int):</strong>  the left limit of the search</li>\n<li><strong>t (float):</strong>  $R^2$ threshold</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: (neighbourhood index, r2, slope)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.get_neighbourhood_fast_points", "modulename": "knee.evaluation", "qualname": "get_neighbourhood_fast_points", "kind": "function", "doc": "<p>Get the neighbourhood (closest points) from a to b.</p>\n\n<p>The neighbourhood is defined as the longest straitgh line (defined by $R^2$).\nThis version uses a inaccurate binary search to speedup the search.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>a (int):</strong>  the initial point of the search</li>\n<li><strong>b (int):</strong>  the left limit of the search</li>\n<li><strong>t (float):</strong>  $R^2$ threshold</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: (neighbourhood index, r2, slope)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.get_neighbourhood_binary", "modulename": "knee.evaluation", "qualname": "get_neighbourhood_binary", "kind": "function", "doc": "<p>Get the index of the point within the range $[b, a]$ where the $R^2$ is close to the threshold.</p>\n\n<p>This version uses a inaccurate binary search to speedup the search.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>a (int):</strong>  the initial point of the search</li>\n<li><strong>b (int):</strong>  the left limit of the search</li>\n<li><strong>t (float):</strong>  $R^2$ threshold (default 0.9)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: index of the point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">0.9</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.get_neighbourhood_fast", "modulename": "knee.evaluation", "qualname": "get_neighbourhood_fast", "kind": "function", "doc": "<p>Get the neighbourhood (closest points) from a to b.</p>\n\n<p>The neighbourhood is defined as the longest straitgh line (defined by $R^2$).\nThis version uses a inaccurate binary search to speedup the search.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>a (int):</strong>  the initial point of the search</li>\n<li><strong>b (int):</strong>  the left limit of the search</li>\n<li><strong>t (float):</strong>  $R^2$ threshold (default 0.9)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: (neighbourhood index, r2, slope)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.9</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.get_neighbourhood", "modulename": "knee.evaluation", "qualname": "get_neighbourhood", "kind": "function", "doc": "<p>Get the neighbourhood (closest points) from a to b.</p>\n\n<p>The neighbourhood is defined as the longest straitgh line (defined by $R^2$).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>a (int):</strong>  the initial point of the search</li>\n<li><strong>b (int):</strong>  the left limit of the search</li>\n<li><strong>t (float):</strong>  $R^2$ threshold (default 0.9)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: (neighbourhood index, r2, slope)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.9</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.accuracy_knee", "modulename": "knee.evaluation", "qualname": "accuracy_knee", "kind": "function", "doc": "<p>Compute the accuracy heuristic for a set of knees.</p>\n\n<p>The heuristic is based on the average distance of X and Y axis, the slope and the $R^2$.\nIn this version it is used the left neighbourhood of the knee.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>t (float):</strong>  $R^2$ threshold (default 0.9)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: (average_x, average_y, average_slope, average_coeffients, cost)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.9</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.accuracy_trace", "modulename": "knee.evaluation", "qualname": "accuracy_trace", "kind": "function", "doc": "<p>Compute the accuracy heuristic for a set of knees.</p>\n\n<p>The heuristic is based on the average distance of X and Y axis, the slope and the $R^2$.\nIn this version it is used the points from the current knee to the previous.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: (average_x, average_y, average_slope, average_coeffients, cost)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.mae", "modulename": "knee.evaluation", "qualname": "mae", "kind": "function", "doc": "<p>Estimates the worst case Mean Absolute Error (MAE) for the given\nknee and expected points.</p>\n\n<p>Suppports different size arrays, and estimates the MAE based \non the worst case.\nIt uses the euclidean distance to find the closer points,\nand computes the error based on the closest point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>expected (np.ndarray):</strong>  numpy array with the expected knee points (x, y)</li>\n<li><strong>s (Strategy):</strong>  enum that controls the point matching (default Strategy.expected)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the worst case MAE</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">expected</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">evaluation</span><span class=\"o\">.</span><span class=\"n\">Strategy</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Strategy</span><span class=\"o\">.</span><span class=\"n\">expected</span><span class=\"p\">:</span> <span class=\"s1\">&#39;expected&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.mse", "modulename": "knee.evaluation", "qualname": "mse", "kind": "function", "doc": "<p>Estimates the worst case Mean Squared Error (MSE) for the given\nknee and expected points.</p>\n\n<p>Suppports different size arrays, and estimates the MSE based \non the worst case.\nIt uses the euclidean distance to find the closer points,\nand computes the error based on the closest point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>expected (np.ndarray):</strong>  numpy array with the expected knee points (x, y)</li>\n<li><strong>s (Strategy):</strong>  enum that controls the point matching (default Strategy.expected)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the worst case MSE</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">expected</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">evaluation</span><span class=\"o\">.</span><span class=\"n\">Strategy</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Strategy</span><span class=\"o\">.</span><span class=\"n\">expected</span><span class=\"p\">:</span> <span class=\"s1\">&#39;expected&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.rmse", "modulename": "knee.evaluation", "qualname": "rmse", "kind": "function", "doc": "<p>Estimates the worst case Root Mean Squared Error (RMSE) for the given\nknee and expected points.</p>\n\n<p>Suppports different size arrays, and estimates the RMSE based \non the worst case.\nIt uses the euclidean distance to find the closer points,\nand computes the error based on the closest point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>expected (np.ndarray):</strong>  numpy array with the expected knee points (x, y)</li>\n<li><strong>s (Strategy):</strong>  enum that controls the point matching (default Strategy.expected)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the worst case RMSE</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">expected</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">evaluation</span><span class=\"o\">.</span><span class=\"n\">Strategy</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Strategy</span><span class=\"o\">.</span><span class=\"n\">expected</span><span class=\"p\">:</span> <span class=\"s1\">&#39;expected&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.rmspe", "modulename": "knee.evaluation", "qualname": "rmspe", "kind": "function", "doc": "<p>Estimates the worst case Root Mean Squared Percentage Error (RMSPE) for the given knee and expected points.</p>\n\n<p>Suppports different size arrays, and estimates the RMSPE based on the worst case.\nIt uses the euclidean distance to find the closer points, and computes the error based on the closest point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>expected (np.ndarray):</strong>  numpy array with the expected knee points (x, y)</li>\n<li><strong>s (Strategy):</strong>  enum that controls the point matching (default Strategy.expected)</li>\n<li><strong>eps (float):</strong>  eps value to prevent division by zero (default: 1E-16)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the worst case RMSPE</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">expected</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">evaluation</span><span class=\"o\">.</span><span class=\"n\">Strategy</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Strategy</span><span class=\"o\">.</span><span class=\"n\">expected</span><span class=\"p\">:</span> <span class=\"s1\">&#39;expected&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.cm", "modulename": "knee.evaluation", "qualname": "cm", "kind": "function", "doc": "<p>Computes the Confusion Matrix based on the knees and expected points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>expected (np.ndarray):</strong>  numpy array with the expected knee points (x, y)</li>\n<li><strong>t (float):</strong>  the maximum allowed distance in percentage (default 0.01)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the confusion matrix</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">expected</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.accuracy", "modulename": "knee.evaluation", "qualname": "accuracy", "kind": "function", "doc": "<p>Computes accuracy based on a Confusion Matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cm (np.ndarray):</strong>  the confusion matrix</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the accuracy</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cm</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.f1score", "modulename": "knee.evaluation", "qualname": "f1score", "kind": "function", "doc": "<p>Computes F1-Score based on a Confusion Matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cm (np.ndarray):</strong>  the confusion matrix</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the F1-Score</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cm</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.mcc", "modulename": "knee.evaluation", "qualname": "mcc", "kind": "function", "doc": "<p>Computes Matthews Correlation Coefficient (MCC) based on a Confusion Matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cm (np.ndarray):</strong>  the confusion matrix</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the mcc</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cm</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.compute_global_rmse", "modulename": "knee.evaluation", "qualname": "compute_global_rmse", "kind": "function", "doc": "<p>Computes the global RMSE for a point reduction set.</p>\n\n<p>For each segment within the point reduction set, computes a straight line.\nFor each line segment it computes the error with the original set.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  the original points</li>\n<li><strong>reduced (np.ndarray):</strong>  the indexes of the reduced points</li>\n<li><strong>cache (dict):</strong>  cache used to speedup the computation (default None)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the global RMSE</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">reduced</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">cache</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.mip", "modulename": "knee.evaluation", "qualname": "mip", "kind": "function", "doc": "<p>Computes the median improvement per point (MIP).</p>\n\n<p>Improvement is defined as a relation between a final cost against a reference cost.\nThe final cost is the RSME with the complete reduced set.\nThe reference cost id different for each point.\nIt is computed as the RMSE of the reconstruction without that specific point. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  the original points</li>\n<li><strong>reduced (np.ndarray):</strong>  the indexes of the reduced points</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the median improvement per point (MIP) and the MAD</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">reduced</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.compute_cost", "modulename": "knee.evaluation", "qualname": "compute_cost", "kind": "function", "doc": "<p>Compute the cost of multi-point fitting using the segment errors.</p>\n\n<p>It uses a cache to speedup the compuation of the cost.\nThe cache contains the cost of previously computed segments.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  the original points</li>\n<li><strong>segment_errors (np.ndarray):</strong>  errors from each of the segments</li>\n<li><strong>cost (metrics.Metrics):</strong>  the metric used for the cost calculation</li>\n<li><strong>cache (dict):</strong>  the cache used to store the segments costs</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the global cost of a multi-point fitting</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">segment_errors</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">Metrics</span>,</span><span class=\"param\">\t<span class=\"n\">cache</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.compute_partial_cost", "modulename": "knee.evaluation", "qualname": "compute_partial_cost", "kind": "function", "doc": "<p>Compute the partial cost of a multi-point fitting.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>y (np.ndarray):</strong>  the y values from the points</li>\n<li><strong>y_hat (np.ndarray):</strong>  the y values computed with the linear aproximation</li>\n<li><strong>cost (metrics.Metrics):</strong>  the metric used for the cost calculation</li>\n<li><strong>eps (float):</strong>  eps value to prevent division by zero (default: 1E-16)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the global cost of a multi-point fitting</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y_hat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">Metrics</span>,</span><span class=\"param\">\t<span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.compute_global_cost", "modulename": "knee.evaluation", "qualname": "compute_global_cost", "kind": "function", "doc": "<p>Compute the cost of multi-point fitting using the segment errors.</p>\n\n<p>It uses a cache to speedup the compuation of the cost.\nThe cache contains the cost of previously computed segments.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  the original points</li>\n<li><strong>reduced (np.ndarray):</strong>  the reduced set of points used for the fitting</li>\n<li><strong>cost (metrics.Metrics):</strong>  the metric used for the cost calculation (default: metrics.Metrics.rpd)</li>\n<li><strong>cache (dict):</strong>  the cache used to store the segments costs (default: None)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the global cost of a multi-point fitting</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">reduced</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">Metrics</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Metrics</span><span class=\"o\">.</span><span class=\"n\">rpd</span><span class=\"p\">:</span> <span class=\"s1\">&#39;rpd&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">cache</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.evaluation.compute_global_segment_cost", "modulename": "knee.evaluation", "qualname": "compute_global_segment_cost", "kind": "function", "doc": "<p>Compute the cost of multi-point fitting using the segment errors.</p>\n\n<p>Legacy function that does not use a cache or combines the segments costs.\nUsed for unit testing.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  the original points</li>\n<li><strong>reduced (np.ndarray):</strong>  the reduced set of points used for the fitting</li>\n<li><strong>cost (metrics.Metrics):</strong>  the metric used for the cost calculation (default: metrics.Metrics.rpd)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the global cost, and partial costs</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">reduced</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">Metrics</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Metrics</span><span class=\"o\">.</span><span class=\"n\">rpd</span><span class=\"p\">:</span> <span class=\"s1\">&#39;rpd&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.knee_ranking", "modulename": "knee.knee_ranking", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.knee_ranking.ClusterRanking", "modulename": "knee.knee_ranking", "qualname": "ClusterRanking", "kind": "class", "doc": "<p>Enum data type that represents the direction of the ranking within a cluster.</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.knee_ranking.ClusterRanking.left", "modulename": "knee.knee_ranking", "qualname": "ClusterRanking.left", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;ClusterRanking.left: &#x27;left&#x27;&gt;"}, {"fullname": "knee.knee_ranking.ClusterRanking.linear", "modulename": "knee.knee_ranking", "qualname": "ClusterRanking.linear", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;ClusterRanking.linear: &#x27;linear&#x27;&gt;"}, {"fullname": "knee.knee_ranking.ClusterRanking.right", "modulename": "knee.knee_ranking", "qualname": "ClusterRanking.right", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;ClusterRanking.right: &#x27;right&#x27;&gt;"}, {"fullname": "knee.knee_ranking.ClusterRanking.hull", "modulename": "knee.knee_ranking", "qualname": "ClusterRanking.hull", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;ClusterRanking.hull: &#x27;hull&#x27;&gt;"}, {"fullname": "knee.knee_ranking.distances", "modulename": "knee.knee_ranking", "qualname": "distances", "kind": "function", "doc": "<p>Computes the euclidean distance from a single point to a vector of points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>point (np.ndarray):</strong>  the point</li>\n<li><strong>points (np.ndarray):</strong>  the vector of points</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: a vector with the distances from point to all the points.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">point</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.knee_ranking.rect_overlap", "modulename": "knee.knee_ranking", "qualname": "rect_overlap", "kind": "function", "doc": "<p>Computes the percentage of the overlap for two rectangles.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>amin (np.ndarray):</strong>  the low point in rectangle A</li>\n<li><strong>amax (np.ndarray):</strong>  the high point in rectangle A</li>\n<li><strong>bmin (np.ndarray):</strong>  the low point in rectangle B</li>\n<li><strong>bmax (np.ndarray):</strong>  the high point in rectangle B</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: percentage of the overlap of two rectangles</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">amin</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">amax</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">bmin</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">bmax</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.knee_ranking.rect", "modulename": "knee.knee_ranking", "qualname": "rect", "kind": "function", "doc": "<p>Creates the low and high rectangle coordinates from 2 points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p1 (np.ndarray):</strong>  one of the points in the rectangle</li>\n<li><strong>p2 (np.ndarray):</strong>  one of the points in the rectangle</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: tuple with two points (low and high)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.knee_ranking.distance_to_similarity", "modulename": "knee.knee_ranking", "qualname": "distance_to_similarity", "kind": "function", "doc": "<p>Converts an array of distances into an array of similarities.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>array (np.ndarray):</strong>  array with distances values</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: an array with similarity values</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.knee_ranking.rank", "modulename": "knee.knee_ranking", "qualname": "rank", "kind": "function", "doc": "<p>Computes the rank of an array of values.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>array (np.ndarray):</strong>  array with values</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: an array with the ranks of each value</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.knee_ranking.slope_ranking", "modulename": "knee.knee_ranking", "qualname": "slope_ranking", "kind": "function", "doc": "<p>Computes the rank of a set of knees in a curve.</p>\n\n<p>The ranking is based on the slope of the left of the knee point.\nThe left neighbourhood is computed based on the R2 metric.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>t (float):</strong>  the R2 threshold for the neighbourhood (default 0.8)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: an array with the ranks of each value</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.8</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.knee_ranking.smooth_ranking", "modulename": "knee.knee_ranking", "qualname": "smooth_ranking", "kind": "function", "doc": "<p>Computes the rank for a cluster of knees in a curve.</p>\n\n<p>The ranking is a weighted raking based on the Y axis improvement and the\nslope/smoothed of the curve.\nThis methods tries to find the best knee within a cluster of knees, this\nmeans that the boundaries for the computation are based on the cluster dimention.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>t (ClusterRanking):</strong>  selects the direction where the curve must be smooth</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: an array with the ranks of each value</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">knee_ranking</span><span class=\"o\">.</span><span class=\"n\">ClusterRanking</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.kneedle", "modulename": "knee.kneedle", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.kneedle.Direction", "modulename": "knee.kneedle", "qualname": "Direction", "kind": "class", "doc": "<p>Enum data type that represents the direction of a concavity.</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.kneedle.Direction.Increasing", "modulename": "knee.kneedle", "qualname": "Direction.Increasing", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Direction.Increasing: &#x27;increasing&#x27;&gt;"}, {"fullname": "knee.kneedle.Direction.Decreasing", "modulename": "knee.kneedle", "qualname": "Direction.Decreasing", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Direction.Decreasing: &#x27;decreasing&#x27;&gt;"}, {"fullname": "knee.kneedle.Concavity", "modulename": "knee.kneedle", "qualname": "Concavity", "kind": "class", "doc": "<p>Enum data type that represents the rotation of a concavity.</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.kneedle.Concavity.Counterclockwise", "modulename": "knee.kneedle", "qualname": "Concavity.Counterclockwise", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Concavity.Counterclockwise: &#x27;counter-clockwise&#x27;&gt;"}, {"fullname": "knee.kneedle.Concavity.Clockwise", "modulename": "knee.kneedle", "qualname": "Concavity.Clockwise", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Concavity.Clockwise: &#x27;clockwise&#x27;&gt;"}, {"fullname": "knee.kneedle.PeakDetection", "modulename": "knee.kneedle", "qualname": "PeakDetection", "kind": "class", "doc": "<p>Enum data type that identifies the peak selection algorithm.</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.kneedle.PeakDetection.Kneedle", "modulename": "knee.kneedle", "qualname": "PeakDetection.Kneedle", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;PeakDetection.Kneedle: &#x27;Kneedle&#x27;&gt;"}, {"fullname": "knee.kneedle.PeakDetection.ZScore", "modulename": "knee.kneedle", "qualname": "PeakDetection.ZScore", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;PeakDetection.ZScore: &#x27;ZScore&#x27;&gt;"}, {"fullname": "knee.kneedle.PeakDetection.Significant", "modulename": "knee.kneedle", "qualname": "PeakDetection.Significant", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;PeakDetection.Significant: &#x27;Significant&#x27;&gt;"}, {"fullname": "knee.kneedle.PeakDetection.All", "modulename": "knee.kneedle", "qualname": "PeakDetection.All", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;PeakDetection.All: &#x27;All&#x27;&gt;"}, {"fullname": "knee.kneedle.differences", "modulename": "knee.kneedle", "qualname": "differences", "kind": "function", "doc": "<p>Computes the differences from the y axis.</p>\n\n<p>These differences represent a rotation within the original algorithm.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>cd (Direction):</strong>  direction of the concavity</li>\n<li><strong>cc (Concavity):</strong>  rotation of the concavity</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the points array with the differences</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">cd</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">kneedle</span><span class=\"o\">.</span><span class=\"n\">Direction</span>,</span><span class=\"param\">\t<span class=\"n\">cc</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">kneedle</span><span class=\"o\">.</span><span class=\"n\">Concavity</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.kneedle.knee", "modulename": "knee.kneedle", "qualname": "knee", "kind": "function", "doc": "<p>Returns the index of the knee point based on the Kneedle method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  tau of the side window used to smooth the curve</li>\n<li><strong>cd (Direction):</strong>  direction of the concavity</li>\n<li><strong>cc (Concavity):</strong>  rotation of the concavity</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the index of the knee point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">cd</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">kneedle</span><span class=\"o\">.</span><span class=\"n\">Direction</span>,</span><span class=\"param\">\t<span class=\"n\">cc</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">kneedle</span><span class=\"o\">.</span><span class=\"n\">Concavity</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.kneedle.knees", "modulename": "knee.kneedle", "qualname": "knees", "kind": "function", "doc": "<p>Returns the index of the knees point based on the Kneedle method.</p>\n\n<p>This implementation uses an heuristic to automatically define\nthe direction and rotation of the concavity.</p>\n\n<p>Furthermore, it support three different methods to select the \nrelevant knees:</p>\n\n<ol>\n<li>Kneedle    : classical algorithm</li>\n<li>Significant: significant knee peak detection</li>\n<li>ZScore     : significant knee peak detection based on zscore</li>\n</ol>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  tau of the sliding window used to smooth the curve</li>\n<li><strong>cd (Direction):</strong>  direction of the concavity</li>\n<li><strong>cc (Concavity):</strong>  rotation of the concavity</li>\n<li><strong>sensitivity (float):</strong>  controls the sensitivity of the peak detection (default 1.0)</li>\n<li><strong>p (PeakDetection):</strong>  selects the peak detection method (default PeakDetection.Kneedle)</li>\n<li><strong>debug (bool):</strong>  debug flag; when True the algorithm returns more information</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the indexes of the knee points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">cd</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">kneedle</span><span class=\"o\">.</span><span class=\"n\">Direction</span>,</span><span class=\"param\">\t<span class=\"n\">cc</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">kneedle</span><span class=\"o\">.</span><span class=\"n\">Concavity</span>,</span><span class=\"param\">\t<span class=\"n\">sensitivity</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">p</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">kneedle</span><span class=\"o\">.</span><span class=\"n\">PeakDetection</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">PeakDetection</span><span class=\"o\">.</span><span class=\"n\">Kneedle</span><span class=\"p\">:</span> <span class=\"s1\">&#39;Kneedle&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.kneedle.auto_knees", "modulename": "knee.kneedle", "qualname": "auto_knees", "kind": "function", "doc": "<p>Returns the index of the knees point based on the Kneedle method.</p>\n\n<p>This implementation uses an heuristic to automatically define\nthe direction and rotation of the concavity.</p>\n\n<p>Furthermore, it support three different methods to select the \nrelevant knees:</p>\n\n<ol>\n<li>Kneedle    : classical algorithm</li>\n<li>Significant: significant knee peak detection</li>\n<li>ZScore     : significant knee peak detection based on zscore</li>\n</ol>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  tau of the side window used to smooth the curve</li>\n<li><strong>sensitivity (float):</strong>  controls the sensitivity of the peak detection</li>\n<li><strong>p (PeakDetection):</strong>  selects the peak detection method</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the indexes of the knee points</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">sensitivity</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">p</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">kneedle</span><span class=\"o\">.</span><span class=\"n\">PeakDetection</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">PeakDetection</span><span class=\"o\">.</span><span class=\"n\">Kneedle</span><span class=\"p\">:</span> <span class=\"s1\">&#39;Kneedle&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.kneedle.auto_knee", "modulename": "knee.kneedle", "qualname": "auto_knee", "kind": "function", "doc": "<p>Returns the index of the knee point based on the Kneedle method.</p>\n\n<p>This implementation uses an heuristic to automatically define\nthe direction and rotation of the concavity.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  tau of the side window used to smooth the curve</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the index of the knee point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.kneedle.multi_knee", "modulename": "knee.kneedle", "qualname": "multi_knee", "kind": "function", "doc": "<p>Recursive knee point detection based on Kneedle.</p>\n\n<p>It returns the knee points on the curve.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t1 (float):</strong>  coefficient of determination threshold (default 0.01)</li>\n<li><strong>t2 (int):</strong>  number of points threshold (default 3)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: knee points on the curve</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span>, </span><span class=\"param\"><span class=\"n\">t1</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>, </span><span class=\"param\"><span class=\"n\">t2</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit", "modulename": "knee.linear_fit", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.linear_fit.linear_fit_points", "modulename": "knee.linear_fit", "qualname": "linear_fit_points", "kind": "function", "doc": "<p>Computes the linear fit for the points.</p>\n\n<p>This methods approximates the linear fit using only the\nfirst and last points in a curve.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: (b, m)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_fit", "modulename": "knee.linear_fit", "qualname": "linear_fit", "kind": "function", "doc": "<p>Computes the linear fit for the points.</p>\n\n<p>This methods approximates the linear fit using only the\nfirst and last points in a curve.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: (b, m)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_transform_points", "modulename": "knee.linear_fit", "qualname": "linear_transform_points", "kind": "function", "doc": "<p>Computes the y values for an x array and the given coefficients.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the corresponding y values</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_transform", "modulename": "knee.linear_fit", "qualname": "linear_transform", "kind": "function", "doc": "<p>Computes the y values for an x array and the given coefficients.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the corresponding y values</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_hv_residuals_points", "modulename": "knee.linear_fit", "qualname": "linear_hv_residuals_points", "kind": "function", "doc": "<p>Computes the residual error from a straight line fitting.</p>\n\n<p>This methods tries a horizontal (typical $f(x)=m \\times x + b$ equation)\nand a vertinal line (a non typical $f(y) = m \\times y + b$ equation).\nIt returns the smaller residual errors.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the residuals of the line fitting.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_hv_residuals", "modulename": "knee.linear_fit", "qualname": "linear_hv_residuals", "kind": "function", "doc": "<p>Computes the residual error from a straight line fitting.</p>\n\n<p>This methods tries a horizontal (typical $f(x)=m \\times x + b$ equation)\nand a vertinal line (a non typical $f(y) = m \\times y + b$ equation).\nIt returns the smaller residual errors.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the residuals of the line fitting.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_fit_transform_points", "modulename": "knee.linear_fit", "qualname": "linear_fit_transform_points", "kind": "function", "doc": "<p>Computes the horizontal or vertical line fitting.</p>\n\n<p>A horizontal line fitting uses the typical $f(x)=m \\times x + b$ equation.\nThe vertinal line fitting uses the non typical $f(y) = m \\times y + b$ equation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>vertical (bool):</strong>  if True computes the vertical line fitting (default: False)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Union[np.ndarray, tuple]: for horizontal retuns only the computed y_hat values.\n  For the vertical line fitting returns the x points and the y_hat values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">vertical</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_fit_transform", "modulename": "knee.linear_fit", "qualname": "linear_fit_transform", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">vertical</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_r2_points", "modulename": "knee.linear_fit", "qualname": "linear_r2_points", "kind": "function", "doc": "<p>Computes the coefficient of determination (R2).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n<li><strong>r2 (R2):</strong>  select the type of coefficient of determination (default: R2.classic)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: coefficient of determination (R2)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">r2</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">R2</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">R2</span><span class=\"o\">.</span><span class=\"n\">classic</span><span class=\"p\">:</span> <span class=\"s1\">&#39;classic&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_r2", "modulename": "knee.linear_fit", "qualname": "linear_r2", "kind": "function", "doc": "<p>Computes the coefficient of determination (R2).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n<li><strong>r2 (R2):</strong>  select the type of coefficient of determination (default: R2.classic)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: coefficient of determination (R2)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">r2</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">R2</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">R2</span><span class=\"o\">.</span><span class=\"n\">classic</span><span class=\"p\">:</span> <span class=\"s1\">&#39;classic&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.rmspe_points", "modulename": "knee.linear_fit", "qualname": "rmspe_points", "kind": "function", "doc": "<p>Computes the Root Mean Squared Percentage Error (RMSPE).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n<li><strong>eps (float):</strong>  eps value to prevent division by zero (default: 1E-16)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Root Mean Squared Percentage Error (RMSPE)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.rmspe", "modulename": "knee.linear_fit", "qualname": "rmspe", "kind": "function", "doc": "<p>Computes the Root Mean Squared Percentage Error (RMSPE).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n<li><strong>eps (float):</strong>  eps value to prevent division by zero (default: 1E-16)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Root Mean Squared Percentage Error (RMSPE)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.rmsle_points", "modulename": "knee.linear_fit", "qualname": "rmsle_points", "kind": "function", "doc": "<p>Computes the Root Mean Squared Log Error (RMSLE):\n$$\nRMSLE(y, \\hat{y}) = \\sqrt{\\frac{\\sum_{i=1}^{n}(\\log (y_i+1) - \\log (\\hat{y_i}+1))^2}{n}}\n$$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Root Mean Squared Log Error (RMSLE)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.rmsle", "modulename": "knee.linear_fit", "qualname": "rmsle", "kind": "function", "doc": "<p>Computes the Root Mean Squared Log Error (RMSLE):\n$$\nRMSLE(y, \\hat{y}) = \\sqrt{\\frac{\\sum_{i=1}^{n}(\\log (y_i+1) - \\log (\\hat{y_i}+1))^2}{n}}\n$$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Root Mean Squared Log Error (RMSLE)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.smape_points", "modulename": "knee.linear_fit", "qualname": "smape_points", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.smape", "modulename": "knee.linear_fit", "qualname": "smape", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.rpd_points", "modulename": "knee.linear_fit", "qualname": "rpd_points", "kind": "function", "doc": "<p>Computes the Relative Percentage Difference (RPD).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n<li><strong>eps (float):</strong>  eps value to prevent division by zero (default: 1E-16)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Relative Percentage Difference (RPD)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.rpd", "modulename": "knee.linear_fit", "qualname": "rpd", "kind": "function", "doc": "<p>Computes the Relative Percentage Difference (RPD).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n<li><strong>eps (float):</strong>  eps value to prevent division by zero (default: 1E-16)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Relative Percentage Difference (RPD)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.rmse_points", "modulename": "knee.linear_fit", "qualname": "rmse_points", "kind": "function", "doc": "<p>Computes the Root Mean Squared Error (RMSE).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Root Mean Squared Error (RMSE)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.rmse", "modulename": "knee.linear_fit", "qualname": "rmse", "kind": "function", "doc": "<p>Computes the Root Mean Squared Error (RMSE).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Root Mean Squared Error (RMSE)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_residuals_points", "modulename": "knee.linear_fit", "qualname": "linear_residuals_points", "kind": "function", "doc": "<p>Computes the residual error of the linear fit.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: residual error of the linear fit</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_residuals", "modulename": "knee.linear_fit", "qualname": "linear_residuals", "kind": "function", "doc": "<p>Computes the residual error of the linear fit.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: residual error of the linear fit</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">coef</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_fit_residuals_points", "modulename": "knee.linear_fit", "qualname": "linear_fit_residuals_points", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.linear_fit_residuals", "modulename": "knee.linear_fit", "qualname": "linear_fit_residuals", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.r2_points", "modulename": "knee.linear_fit", "qualname": "r2_points", "kind": "function", "doc": "<p>Computes the coefficient of determination (R2).</p>\n\n<p>Computes the best fit (and not the fast point fit)\nand computes the corresponding R2.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (R2):</strong>  select the type of coefficient of determination</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: coefficient of determination (R2)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">R2</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">R2</span><span class=\"o\">.</span><span class=\"n\">classic</span><span class=\"p\">:</span> <span class=\"s1\">&#39;classic&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.r2", "modulename": "knee.linear_fit", "qualname": "r2", "kind": "function", "doc": "<p>Computes the coefficient of determination (R2).</p>\n\n<p>Computes the best fit (and not the fast point fit)\nand computes the corresponding R2.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>t (R2):</strong>  select the type of coefficient of determination</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: coefficient of determination (R2)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">R2</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">R2</span><span class=\"o\">.</span><span class=\"n\">classic</span><span class=\"p\">:</span> <span class=\"s1\">&#39;classic&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.angle", "modulename": "knee.linear_fit", "qualname": "angle", "kind": "function", "doc": "<p>Computes the angle between two lines.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coef1 (tuple):</strong>  the coefficients from the first line</li>\n<li><strong>coef2 (tuple):</strong>  the coefficients from the second line</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the angle between two lines $\\left[0,\\frac{\\pi}{2} \\right]$</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">coef1</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">coef2</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.shortest_distance_points", "modulename": "knee.linear_fit", "qualname": "shortest_distance_points", "kind": "function", "doc": "<p>Computes the shortest distance from the points to the \nstraight line defined by the left and right point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pt (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>start (np.ndarray):</strong>  the left point</li>\n<li><strong>end (np.ndarray):</strong>  the right point</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the perpendicular distances</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.perpendicular_distance", "modulename": "knee.linear_fit", "qualname": "perpendicular_distance", "kind": "function", "doc": "<p>Computes the perpendicular distance from the points to the \nstraight line defined by the first and last point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the perpendicular distances</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.perpendicular_distance_index", "modulename": "knee.linear_fit", "qualname": "perpendicular_distance_index", "kind": "function", "doc": "<p>Computes the perpendicular distance from the points to the \nstraight line defined by the left and right point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>left (int):</strong>  the index of the left point</li>\n<li><strong>right (int):</strong>  the index of the right point</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the perpendicular distances</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">left</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">right</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.linear_fit.perpendicular_distance_points", "modulename": "knee.linear_fit", "qualname": "perpendicular_distance_points", "kind": "function", "doc": "<p>Computes the perpendicular distance from the points to the \nstraight line defined by the left and right point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pt (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>start (np.ndarray):</strong>  the left point</li>\n<li><strong>end (np.ndarray):</strong>  the right point</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the perpendicular distances</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pt</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.lmethod", "modulename": "knee.lmethod", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.lmethod.Fit", "modulename": "knee.lmethod", "qualname": "Fit", "kind": "class", "doc": "<p>Enum that defines the types of linear fitting</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.lmethod.Fit.best_fit", "modulename": "knee.lmethod", "qualname": "Fit.best_fit", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Fit.best_fit: &#x27;bestfit&#x27;&gt;"}, {"fullname": "knee.lmethod.Fit.point_fit", "modulename": "knee.lmethod", "qualname": "Fit.point_fit", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Fit.point_fit: &#x27;pointfit&#x27;&gt;"}, {"fullname": "knee.lmethod.Cost", "modulename": "knee.lmethod", "qualname": "Cost", "kind": "class", "doc": "<p>Enum that defines the cost used in L-method</p>\n\n<p>RMSE was originaly used by the original authors.\nRSS can be used to speedup the computation \n(it has similar results in most practical cases).</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.lmethod.Cost.rss", "modulename": "knee.lmethod", "qualname": "Cost.rss", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Cost.rss: &#x27;rss&#x27;&gt;"}, {"fullname": "knee.lmethod.Cost.rmse", "modulename": "knee.lmethod", "qualname": "Cost.rmse", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Cost.rmse: &#x27;rmse&#x27;&gt;"}, {"fullname": "knee.lmethod.Refinement", "modulename": "knee.lmethod", "qualname": "Refinement", "kind": "class", "doc": "<p>Enum that defines the iterative refinement used in L-method</p>\n\n<p>none as the name implies, it avoids the iterative refinement\noriginal apply the iterative refinement from the paper\nadjusted applies a variant that should be stable on noisy data</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.lmethod.Refinement.none", "modulename": "knee.lmethod", "qualname": "Refinement.none", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Refinement.none: &#x27;none&#x27;&gt;"}, {"fullname": "knee.lmethod.Refinement.original", "modulename": "knee.lmethod", "qualname": "Refinement.original", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Refinement.original: &#x27;original&#x27;&gt;"}, {"fullname": "knee.lmethod.Refinement.adjusted", "modulename": "knee.lmethod", "qualname": "Refinement.adjusted", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Refinement.adjusted: &#x27;adjusted&#x27;&gt;"}, {"fullname": "knee.lmethod.compute_error", "modulename": "knee.lmethod", "qualname": "compute_error", "kind": "function", "doc": "<p>Returns the fitting error that is minimized by the L-method algorithm.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>index (int):</strong>  the index where the fitting line is divided</li>\n<li><strong>lenght (int):</strong>  the lenght of the points considered</li>\n<li><strong>fit (Fit):</strong>  select between point fit and best fit</li>\n<li><strong>cost (Cost):</strong>  use either RMSE (original work) or RSS (faster implementation)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the fitting cost</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">length</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">fit</span><span class=\"o\">=&lt;</span><span class=\"n\">Fit</span><span class=\"o\">.</span><span class=\"n\">point_fit</span><span class=\"p\">:</span> <span class=\"s1\">&#39;pointfit&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"o\">=&lt;</span><span class=\"n\">Cost</span><span class=\"o\">.</span><span class=\"n\">rmse</span><span class=\"p\">:</span> <span class=\"s1\">&#39;rmse&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "knee.lmethod.get_knee", "modulename": "knee.lmethod", "qualname": "get_knee", "kind": "function", "doc": "<p>Returns the index of the knee point based on the L-method.</p>\n\n<p>This method does not use the iterative refinement.\nIt represents a single iteration of the refinement technique.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x (np.ndarray):</strong>  the value of the points in the x axis coordinates</li>\n<li><strong>y (np.ndarray):</strong>  the value of the points in the y axis coordinates</li>\n<li><strong>fit (Fit):</strong>  select between point fit and best fit</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the index of the knee point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">fit</span><span class=\"o\">=&lt;</span><span class=\"n\">Fit</span><span class=\"o\">.</span><span class=\"n\">point_fit</span><span class=\"p\">:</span> <span class=\"s1\">&#39;pointfit&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"o\">=&lt;</span><span class=\"n\">Cost</span><span class=\"o\">.</span><span class=\"n\">rmse</span><span class=\"p\">:</span> <span class=\"s1\">&#39;rmse&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.lmethod.knee", "modulename": "knee.lmethod", "qualname": "knee", "kind": "function", "doc": "<p>Returns the index of the knee point based on the L-method.</p>\n\n<p>This method uses iterative refinement.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>fit (Fit):</strong>  select between point fit and best fit (Fit.point_fit)</li>\n<li><strong>it (Refinement):</strong>  defines the iterative refinement method (Refinement.adjusted)</li>\n<li><strong>limit(int):</strong>  minimal number of points for the fitted lines (10)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the index of the knee point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">fit</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">lmethod</span><span class=\"o\">.</span><span class=\"n\">Fit</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Fit</span><span class=\"o\">.</span><span class=\"n\">point_fit</span><span class=\"p\">:</span> <span class=\"s1\">&#39;pointfit&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">it</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">lmethod</span><span class=\"o\">.</span><span class=\"n\">Refinement</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Refinement</span><span class=\"o\">.</span><span class=\"n\">adjusted</span><span class=\"p\">:</span> <span class=\"s1\">&#39;adjusted&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.lmethod.multi_knee", "modulename": "knee.lmethod", "qualname": "multi_knee", "kind": "function", "doc": "<p>Recursive knee point detection based on the L-method.</p>\n\n<p>It returns the knee points on the curve.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t1 (float):</strong>  coefficient of determination threshold (default 0.01)</li>\n<li><strong>t2 (int):</strong>  number of points threshold (default 3)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: knee points on the curve</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">t1</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>, </span><span class=\"param\"><span class=\"n\">t2</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">4</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.menger", "modulename": "knee.menger", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.menger.menger_curvature", "modulename": "knee.menger", "qualname": "menger_curvature", "kind": "function", "doc": "<p>Computes the menger curvature based on three points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>f (np.ndarray):</strong>  first point</li>\n<li><strong>g (np.ndarray):</strong>  second point</li>\n<li><strong>h (np.ndarray):</strong>  third point</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: menger curvature</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">g</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.menger.knee", "modulename": "knee.menger", "qualname": "knee", "kind": "function", "doc": "<p>Returns the index of the knee point based on the menger curvature.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the index of the knee point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.menger.multi_knee", "modulename": "knee.menger", "qualname": "multi_knee", "kind": "function", "doc": "<p>Recursive knee point detection based on the menger curvature.</p>\n\n<p>It returns the knee points on the curve.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t1 (float):</strong>  coefficient of determination threshold (default 0.01)</li>\n<li><strong>t2 (int):</strong>  number of points threshold (default 4)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: knee points on the curve</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">t1</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>, </span><span class=\"param\"><span class=\"n\">t2</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">4</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.metrics", "modulename": "knee.metrics", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.metrics.Metrics", "modulename": "knee.metrics", "qualname": "Metrics", "kind": "class", "doc": "<p>Enum that defines the different metrics linear functions.\nThese metrics are used on the <code>knee.rdp</code> and <code>knee.multi_knee</code>.</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.metrics.Metrics.r2", "modulename": "knee.metrics", "qualname": "Metrics.r2", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Metrics.r2: &#x27;r2&#x27;&gt;"}, {"fullname": "knee.metrics.Metrics.rmspe", "modulename": "knee.metrics", "qualname": "Metrics.rmspe", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Metrics.rmspe: &#x27;rmspe&#x27;&gt;"}, {"fullname": "knee.metrics.Metrics.rmsle", "modulename": "knee.metrics", "qualname": "Metrics.rmsle", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Metrics.rmsle: &#x27;rmsle&#x27;&gt;"}, {"fullname": "knee.metrics.Metrics.rpd", "modulename": "knee.metrics", "qualname": "Metrics.rpd", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Metrics.rpd: &#x27;rpd&#x27;&gt;"}, {"fullname": "knee.metrics.Metrics.smape", "modulename": "knee.metrics", "qualname": "Metrics.smape", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Metrics.smape: &#x27;smape&#x27;&gt;"}, {"fullname": "knee.metrics.R2", "modulename": "knee.metrics", "qualname": "R2", "kind": "class", "doc": "<p>Enum that defines the types of coefficient of determination</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.metrics.R2.adjusted", "modulename": "knee.metrics", "qualname": "R2.adjusted", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;R2.adjusted: &#x27;adjusted&#x27;&gt;"}, {"fullname": "knee.metrics.R2.classic", "modulename": "knee.metrics", "qualname": "R2.classic", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;R2.classic: &#x27;classic&#x27;&gt;"}, {"fullname": "knee.metrics.r2", "modulename": "knee.metrics", "qualname": "r2", "kind": "function", "doc": "<p>Computes the coefficient of determination (R2).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>y (np.ndarray):</strong>  the real value of the points in the y axis coordinates</li>\n<li><strong>y_hat (np.ndarray):</strong>  the predicted value of the points in the y axis coordinates</li>\n<li><strong>r2 (R2):</strong>  select the type of coefficient of determination (default: R2.classic)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: coefficient of determination (R2)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y_hat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">r2</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">R2</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">R2</span><span class=\"o\">.</span><span class=\"n\">classic</span><span class=\"p\">:</span> <span class=\"s1\">&#39;classic&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.metrics.rmse", "modulename": "knee.metrics", "qualname": "rmse", "kind": "function", "doc": "<p>Computes the Root Mean Squared Error (RMSE).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>y (np.ndarray):</strong>  the real value of the points in the y axis coordinates</li>\n<li><strong>y_hat (np.ndarray):</strong>  the predicted value of the points in the y axis coordinates</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Root Mean Squared Error (RMSE)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y_hat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.metrics.rmsle", "modulename": "knee.metrics", "qualname": "rmsle", "kind": "function", "doc": "<p>Computes the Root Mean Squared Log Error (RMSLE):\n$$\nRMSLE(y, \\hat{y}) = \\sqrt{\\frac{\\sum_{i=1}^{n}(\\log (y_i+1) - \\log (\\hat{y_i}+1))^2}{n}}\n$$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>y (np.ndarray):</strong>  the real value of the points in the y axis coordinates</li>\n<li><strong>y_hat (np.ndarray):</strong>  the predicted value of the points in the y axis coordinates</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Root Mean Squared Log Error (RMSLE)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y_hat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.metrics.rmspe", "modulename": "knee.metrics", "qualname": "rmspe", "kind": "function", "doc": "<p>Computes the Root Mean Squared Percentage Error (RMSPE).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>y (np.ndarray):</strong>  the real value of the points in the y axis coordinates</li>\n<li><strong>y_hat (np.ndarray):</strong>  the predicted value of the points in the y axis coordinates</li>\n<li><strong>eps (float):</strong>  eps value to prevent division by zero (default: 1E-16)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Root Mean Squared Percentage Error (RMSPE)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y_hat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.metrics.rpd", "modulename": "knee.metrics", "qualname": "rpd", "kind": "function", "doc": "<p>Computes the Relative Percentage Difference (RPD).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>y (np.ndarray):</strong>  the real value of the points in the y axis coordinates</li>\n<li><strong>y_hat (np.ndarray):</strong>  the predicted value of the points in the y axis coordinates</li>\n<li><strong>eps (float):</strong>  eps value to prevent division by zero (default: 1E-16)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: Relative Percentage Difference (RPD)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y_hat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.metrics.residuals", "modulename": "knee.metrics", "qualname": "residuals", "kind": "function", "doc": "<p>Computes the residual error of the fit.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>y (np.ndarray):</strong>  the real value of the points in the y axis coordinates</li>\n<li><strong>y_hat (np.ndarray):</strong>  the predicted value of the points in the y axis coordinates</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: residual error of the fit</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y_hat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.metrics.smape", "modulename": "knee.metrics", "qualname": "smape", "kind": "function", "doc": "<p>Computes Symmetric Mean Absolute Percentage Error (SMAPE).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>y (np.ndarray):</strong>  the real value of the points in the y axis coordinates</li>\n<li><strong>y_hat (np.ndarray):</strong>  the predicted value of the points in the y axis coordinates</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: residual error of the fit</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">y_hat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-16</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.multi_knee", "modulename": "knee.multi_knee", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.multi_knee.multi_knee", "modulename": "knee.multi_knee", "qualname": "multi_knee", "kind": "function", "doc": "<p>Wrapper that convert a single knee point detection into a multi knee point detector.</p>\n\n<p>It uses recursion on the left and right parts of the curve after detecting the current knee.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>get_knee (callable):</strong>  method that returns a single knee point</li>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t1 (float):</strong>  the coefficient of determination used as a threshold (default 0.01)</li>\n<li><strong>t2 (int):</strong>  the mininum number of points used as a threshold (default 3)</li>\n<li><strong>cost (lf.Linear_Metrics):</strong>  the cost method used to evaluate a point set (default: lf.Linear_Metrics.rmspe)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: knee points on the curve</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">get_knee</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">callable</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t1</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">t2</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">Metrics</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Metrics</span><span class=\"o\">.</span><span class=\"n\">rpd</span><span class=\"p\">:</span> <span class=\"s1\">&#39;rpd&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.postprocessing", "modulename": "knee.postprocessing", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.postprocessing.filter_corner_knees", "modulename": "knee.postprocessing", "qualname": "filter_corner_knees", "kind": "function", "doc": "<p>Filter the left upper corner knees points.</p>\n\n<p>A left upper knee corner does not provide a significant improvement to be considered.\nThe detection method relies on a three point rectangle fitting and overlap.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>t (float):</strong>  overlap treshold (default 0.33)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the filtered knees</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.33</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.postprocessing.select_corner_knees", "modulename": "knee.postprocessing", "qualname": "select_corner_knees", "kind": "function", "doc": "<p>Detect and keep the left upper corner knees points.</p>\n\n<p>The detection method relies on a three point rectangle fitting and overlap.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>t (float):</strong>  overlap treshold (default 0.33)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the filtered knees</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.33</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.postprocessing.filter_worst_knees", "modulename": "knee.postprocessing", "qualname": "filter_worst_knees", "kind": "function", "doc": "<p>Filter the worst knees points.</p>\n\n<p>A worst knee is a knee that is higher (at y axis) than a previous knee.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the filtered knees</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.postprocessing.filter_clusters", "modulename": "knee.postprocessing", "qualname": "filter_clusters", "kind": "function", "doc": "<p>Filter the knee points based on clustering.</p>\n\n<p>For each cluster a single point is selected based on the ranking.\nThe ranking is computed based on the slope and the improvement (on the y axis).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>clustering (callable):</strong>  the clustering function</li>\n<li><strong>t (float):</strong>  the threshold for merging (in percentage, default 0.01)</li>\n<li><strong>method (ranking.ClusterRanking):</strong>  represents the direction of the ranking within a cluster (default ranking.ClusterRanking.linear)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the filtered knees</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">clustering</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">callable</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">knee_ranking</span><span class=\"o\">.</span><span class=\"n\">ClusterRanking</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">ClusterRanking</span><span class=\"o\">.</span><span class=\"n\">linear</span><span class=\"p\">:</span> <span class=\"s1\">&#39;linear&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.postprocessing.filter_clusters_corners", "modulename": "knee.postprocessing", "qualname": "filter_clusters_corners", "kind": "function", "doc": "<p>This methods finds and removes corner points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>clustering (callable):</strong>  the clustering function</li>\n<li><strong>t (float):</strong>  the threshold for merging (in percentage, default 0.01)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the filtered knees</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">clustering</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">callable</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.postprocessing.add_points_even", "modulename": "knee.postprocessing", "qualname": "add_points_even", "kind": "function", "doc": "<p>Add evenly spaced points between knees points.</p>\n\n<p>Whenever a smooth segment between two knew points are\nfurther away than tx (on the X-axis) and ty (on the Y axis),\neven spaced points are added to the result.\nThis function will map the knees (in RDP space) into \nthe space of the complete set of points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>reduced (np.ndarray):</strong>  numpy array with the index of the reduced points (x, y) (simplified by RDP)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>removed (np.ndarray):</strong>  the points that were removed</li>\n<li><strong>tx (float):</strong>  the threshold (X-axis) for adding points (in percentage, default 0.05)</li>\n<li><strong>ty (float):</strong>  the threshold (Y-axis) for adding points (in percentage, default 0.05)</li>\n<li><strong>extremes (bool):</strong>  if True adds the extreme points (firt and last) (default False)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the resulting knees (mapped into the complete set of points)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">reduced</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">removed</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tx</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">ty</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">extremes</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.postprocessing.add_points_even_knees", "modulename": "knee.postprocessing", "qualname": "add_points_even_knees", "kind": "function", "doc": "<p>Add evenly spaced points between knees points (using knee as markers).</p>\n\n<p>Whenever the distance between two consequetive knees is greater than \ntx (on the X-axis) and ty (on the Y axis), even spaced points are \nadded to the result.\nThe knees have to be mapped in the complete set of points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n<li><strong>tx (float):</strong>  the threshold (X-axis) for adding points (in percentage, default 0.05)</li>\n<li><strong>ty (float):</strong>  the threshold (Y-axis) for adding points (in percentage, default 0.05)</li>\n<li><strong>extremes (bool):</strong>  if True adds the extreme points (firt and last) (default False)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the resulting knees</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tx</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">ty</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">extremes</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.postprocessing.triangle_area", "modulename": "knee.postprocessing", "qualname": "triangle_area", "kind": "function", "doc": "<p>Given 3 points computes the triangle area.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p (np.ndarray):</strong>  numpy array with 3 2D points (x, y)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: triange area</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.postprocessing.rank_corners_triangle", "modulename": "knee.postprocessing", "qualname": "rank_corners_triangle", "kind": "function", "doc": "<p>Ranks knees based on the triangle fast heuristic.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the ranks</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.postprocessing.rank_corners", "modulename": "knee.postprocessing", "qualname": "rank_corners", "kind": "function", "doc": "<p>Ranks knees based on their corners.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>knees (np.ndarray):</strong>  knees indexes</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the ranks</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">knees</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp", "modulename": "knee.rdp", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.rdp.Distance", "modulename": "knee.rdp", "qualname": "Distance", "kind": "class", "doc": "<p>Enum that defines the distance method for the RDP</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.rdp.Distance.perpendicular", "modulename": "knee.rdp", "qualname": "Distance.perpendicular", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Distance.perpendicular: &#x27;perpendicular&#x27;&gt;"}, {"fullname": "knee.rdp.Distance.shortest", "modulename": "knee.rdp", "qualname": "Distance.shortest", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Distance.shortest: &#x27;shortest&#x27;&gt;"}, {"fullname": "knee.rdp.Order", "modulename": "knee.rdp", "qualname": "Order", "kind": "class", "doc": "<p>Enum that defines the distance method for the RDP</p>\n", "bases": "enum.Enum"}, {"fullname": "knee.rdp.Order.triangle", "modulename": "knee.rdp", "qualname": "Order.triangle", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Order.triangle: &#x27;triangle&#x27;&gt;"}, {"fullname": "knee.rdp.Order.area", "modulename": "knee.rdp", "qualname": "Order.area", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Order.area: &#x27;area&#x27;&gt;"}, {"fullname": "knee.rdp.Order.segment", "modulename": "knee.rdp", "qualname": "Order.segment", "kind": "variable", "doc": "<p></p>\n", "default_value": " = &lt;Order.segment: &#x27;segment&#x27;&gt;"}, {"fullname": "knee.rdp.mapping", "modulename": "knee.rdp", "qualname": "mapping", "kind": "function", "doc": "<p>Computes the reverse of the RDP method.</p>\n\n<p>It maps the indexes on a simplified curve (using the rdp algorithm) into\nthe indexes of the original points.\nThis method assumes the indexes are sorted in ascending order.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>indexes (np.ndarray):</strong>  the indexes in the reduced space</li>\n<li><strong>reduced (np.ndarray):</strong>  the points that form the reduced space</li>\n<li><strong>removed (np.ndarray):</strong>  the points that were removed</li>\n<li><strong>sorted (bool):</strong>  True if the removed array is already sorted</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the indexes in the original space</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indexes</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">reduced</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">removed</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"nb\">sorted</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp.compute_cost_coef", "modulename": "knee.rdp", "qualname": "compute_cost_coef", "kind": "function", "doc": "<p>Computes the cost of fitting a linear function (with a given coefficient)\nin the points array.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>coef (tuple):</strong>  the coefficients from the linear fit</li>\n<li><strong>cost (lf.Linear_Metrics):</strong>  the cost method used to evaluate a point set (default: metrics.Metrics.smape)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: the cost of fitting the linear function</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pt</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">coef</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">Metrics</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Metrics</span><span class=\"o\">.</span><span class=\"n\">smape</span><span class=\"p\">:</span> <span class=\"s1\">&#39;smape&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp.rdp", "modulename": "knee.rdp", "qualname": "rdp", "kind": "function", "doc": "<p>Ramer\u2013Douglas\u2013Peucker (RDP) algorithm.</p>\n\n<p>Is an algorithm that decimates a curve composed of line segments to a similar curve with fewer points.\nThis version uses different cost functions to decided whenever to keep or remove a line segment.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  the coefficient of determination threshold (default 0.01)</li>\n<li><strong>distance (Distance):</strong>  the distance metric used to decide the split point (default: Distance.shortest)</li>\n<li><strong>cost (metrics.Metrics):</strong>  the cost method used to evaluate a point set (default: metrics.Metrics.smape)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the index of the reduced space, the points that were removed</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">distance</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">rdp</span><span class=\"o\">.</span><span class=\"n\">Distance</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Distance</span><span class=\"o\">.</span><span class=\"n\">shortest</span><span class=\"p\">:</span> <span class=\"s1\">&#39;shortest&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">Metrics</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Metrics</span><span class=\"o\">.</span><span class=\"n\">smape</span><span class=\"p\">:</span> <span class=\"s1\">&#39;smape&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp.compute_removed_points", "modulename": "knee.rdp", "qualname": "compute_removed_points", "kind": "function", "doc": "<p>Given an array of points and the reduced set it computes how many\npoints were removed per segment.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>reduced (np.ndarray):</strong>  numpy array with the reduced set of points</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: the points that were removed</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">reduced</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp.order_triangle", "modulename": "knee.rdp", "qualname": "order_triangle", "kind": "function", "doc": "<p>Computes the triangle area of the left and right segments.\nThe triangle area is a fast heuristic to estimate the how curve\nthe left and right segment are.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pt (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>index (int):</strong>  the index that separates the left from the right segment</li>\n<li><strong>distance_points (callable):</strong>  methods that computes the distance between points</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the left and right triangle area</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pt</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">distance_points</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">callable</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp.order_area", "modulename": "knee.rdp", "qualname": "order_area", "kind": "function", "doc": "<p>Computes the area of the left and right segments.\nThe area is an heuristic to estimate the how curve\nthe left and right segment are.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pt (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>index (int):</strong>  the index that separates the left from the right segment</li>\n<li><strong>distance_points (callable):</strong>  methods that computes the distance between points</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the left and right area</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pt</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">distance_points</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">callable</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp.order_segment", "modulename": "knee.rdp", "qualname": "order_segment", "kind": "function", "doc": "<p>Computes the fitting error for the left and right segments.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pt (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>index (int):</strong>  the index that separates the left from the right segment</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the left and right fitting error</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pt</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp.rdp_fixed", "modulename": "knee.rdp", "qualname": "rdp_fixed", "kind": "function", "doc": "<p>Ramer\u2013Douglas\u2013Peucker (RDP) algorithm.</p>\n\n<p>Is an algorithm that decimates a curve composed of line segments to a similar curve with fewer points.\nThis version reduces the number of points to a fixed length.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>length (int):</strong>  the fixed length of reduced points (default: 10)</li>\n<li><strong>distance (Distance):</strong>  the distance metric used to decide the split point (default: Distance.shortest)</li>\n<li><strong>order (Order):</strong>  the metric used to sort the segments (default: Order.segment)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the index of the reduced space, the points that were removed</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">length</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">distance</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">rdp</span><span class=\"o\">.</span><span class=\"n\">Distance</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Distance</span><span class=\"o\">.</span><span class=\"n\">shortest</span><span class=\"p\">:</span> <span class=\"s1\">&#39;shortest&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">order</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">rdp</span><span class=\"o\">.</span><span class=\"n\">Order</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Order</span><span class=\"o\">.</span><span class=\"n\">segment</span><span class=\"p\">:</span> <span class=\"s1\">&#39;segment&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp.grdp", "modulename": "knee.rdp", "qualname": "grdp", "kind": "function", "doc": "<p>Global Ramer\u2013Douglas\u2013Peucker (RDP) algorithm.</p>\n\n<p>Is an algorithm that decimates a curve composed of line segments to a similar curve with fewer points.\nThis version computes the global cost of reconstruction (instead of the cost of the current segment).\nIt uses a cache to keep the cost of the segments that are not being explored right now.\nThe exploration is based on the segment that has an overall higher reconstruction error.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  the coefficient of determination threshold (default 0.01)</li>\n<li><strong>distance (Distance):</strong>  the distance metric used to decide the split point (default: Distance.shortest)</li>\n<li><strong>cost (metrics.Metrics):</strong>  the cost method used to evaluate a point set (default: metrics.Metrics.smape)</li>\n<li><strong>order (Order):</strong>  the metric used to sort the segments (default: Order.segment)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the index of the reduced space, the points that were removed</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">distance</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">rdp</span><span class=\"o\">.</span><span class=\"n\">Distance</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Distance</span><span class=\"o\">.</span><span class=\"n\">shortest</span><span class=\"p\">:</span> <span class=\"s1\">&#39;shortest&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">Metrics</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Metrics</span><span class=\"o\">.</span><span class=\"n\">smape</span><span class=\"p\">:</span> <span class=\"s1\">&#39;smape&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">order</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">rdp</span><span class=\"o\">.</span><span class=\"n\">Order</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Order</span><span class=\"o\">.</span><span class=\"n\">segment</span><span class=\"p\">:</span> <span class=\"s1\">&#39;segment&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp.mp_grdp", "modulename": "knee.rdp", "qualname": "mp_grdp", "kind": "function", "doc": "<p>MP gRDP (Min Points Global RDP)</p>\n\n<p>This version computes the gRDP with the given threshold.\nAt the end, if the minimum number of points constraint is not satisfied\nit executes the rdp_fixed version.</p>\n\n<p>This method stores the reduced set and stack of the gRDP, meaning that\nthe rdp_fixed method continues from the previous point onwards.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  the coefficient of determination threshold (default 0.01)</li>\n<li><strong>min_points (int):</strong>  the minimal amount of points (default 10)</li>\n<li><strong>distance (Distance):</strong>  the distance metric used to decide the split point (default: Distance.shortest)</li>\n<li><strong>cost (metrics.Metrics):</strong>  the cost method used to evaluate a point set (default: metrics.Metrics.smape)</li>\n<li><strong>order (Order):</strong>  the metric used to sort the segments (default: Order.segment)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the index of the reduced space, the points that were removed</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">min_points</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">distance</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">rdp</span><span class=\"o\">.</span><span class=\"n\">Distance</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Distance</span><span class=\"o\">.</span><span class=\"n\">shortest</span><span class=\"p\">:</span> <span class=\"s1\">&#39;shortest&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">Metrics</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Metrics</span><span class=\"o\">.</span><span class=\"n\">smape</span><span class=\"p\">:</span> <span class=\"s1\">&#39;smape&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">order</span><span class=\"p\">:</span> <span class=\"n\">knee</span><span class=\"o\">.</span><span class=\"n\">rdp</span><span class=\"o\">.</span><span class=\"n\">Order</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Order</span><span class=\"o\">.</span><span class=\"n\">segment</span><span class=\"p\">:</span> <span class=\"s1\">&#39;segment&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.rdp.min_point_rdp", "modulename": "knee.rdp", "qualname": "min_point_rdp", "kind": "function", "doc": "<p>Minimal points RDP.</p>\n\n<p>Given a minimal amount of points, this version runs Global RDP with different threshold \nvalues. The thresholds are sorted in decreasing order.\nThe method returns as soon as a threshold value returns a minimal amount of points.\nIf necessary the method will execute the fixed version of RDP to get the exact amount of points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>t (float):</strong>  a list of coefficient of determination thresholds (default [0.01, 0.001, 0.0001])</li>\n<li><strong>min_points (int):</strong>  the minimal amount of points (default 10)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: the index of the reduced space, the points that were removed</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.01</span><span class=\"p\">,</span> <span class=\"mf\">0.001</span><span class=\"p\">,</span> <span class=\"mf\">0.0001</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">min_points</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.zmethod", "modulename": "knee.zmethod", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "knee.zmethod.map_index", "modulename": "knee.zmethod", "qualname": "map_index", "kind": "function", "doc": "<p>Maps the knee points into indexes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>a (np.ndarray):</strong>  numpy array with the points (x)</li>\n<li><strong>b (np.ndarray):</strong>  numpy array with the knee points points (x)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The knee indexes</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.zmethod.knees", "modulename": "knee.zmethod", "qualname": "knees", "kind": "function", "doc": "<p>Given an array of points, it computes the knees.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>dx (float):</strong>  % of max cache size between points (default 0.05)</li>\n<li><strong>dy (float):</strong>  % of max - min miss ratio between points (default 0.05)</li>\n<li><strong>dz (float):</strong>  amount we decrease outlier_z every iteration (default 0.05)</li>\n<li><strong>x_max (int):</strong>  max cache size of original (pre-RDP) MRC  (default None)</li>\n<li><strong>y_max (list):</strong>  [max, min] miss ratio of original (pre-RDP) MRC (default None)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The knee points on the curve</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">dx</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">dy</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">dz</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">x_max</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">y_range</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "knee.zmethod.getPoints", "modulename": "knee.zmethod", "qualname": "getPoints", "kind": "function", "doc": "<p>Use our outlier method to find interesting points in an MRC.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points (np.ndarray):</strong>  numpy array with the points (x, y)</li>\n<li><strong>dx (float):</strong>  % of max cache size between points (default 0.05)</li>\n<li><strong>dy (float):</strong>  % of max - min miss ratio between points (default 0.05)</li>\n<li><strong>dz (float):</strong>  amount we decrease outlier_z every iteration (default 0.05)</li>\n<li><strong>plot (bool):</strong>  set True if you want to return data useful for plotting</li>\n<li><strong>x_max (int):</strong>  max cache size of original (pre-RDP) MRC (default None)</li>\n<li><strong>y_max (list):</strong>  [max, min] miss ratio of original (pre-RDP) MRC (default None)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: list with the knees x coordinate</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">dx</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">dy</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">dz</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">plot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">x_max</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">y_range</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();